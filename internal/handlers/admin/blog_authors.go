package admin

import (
	// Standard library imports for data handling and HTTP operations
	"database/sql" // Handles SQL NULL types for optional fields (bio, avatar_url, etc.)
	"log/slog"     // Structured logging for error tracking
	"net/http"     // HTTP status codes and error responses
	"strconv"      // String to integer conversions for IDs and sort_order

	// Third-party framework imports
	"github.com/labstack/echo/v4" // Echo web framework for routing and context handling

	// Internal application imports
	"github.com/narendhupati/bluejay-cms/db/sqlc" // Generated SQL queries via sqlc
)

// BlogAuthorsHandler manages all HTTP handlers for blog author CRUD operations.
// Handles listing, creating, editing, updating, and deleting blog authors.
type BlogAuthorsHandler struct {
	queries *sqlc.Queries // Database query interface generated by sqlc
	logger  *slog.Logger  // Structured logger for error tracking
}

// NewBlogAuthorsHandler constructs a new BlogAuthorsHandler with required dependencies.
func NewBlogAuthorsHandler(queries *sqlc.Queries, logger *slog.Logger) *BlogAuthorsHandler {
	return &BlogAuthorsHandler{queries: queries, logger: logger}
}

// List handles GET /admin/blog-authors
// Renders the complete list of all blog authors without pagination.
// Template: admin/pages/blog_authors_list.html (full page)
// Authors are typically displayed in sort_order ascending.
func (h *BlogAuthorsHandler) List(c echo.Context) error {
	// Fetch all blog authors from the database
	items, err := h.queries.ListBlogAuthors(c.Request().Context())
	if err != nil {
		h.logger.Error("failed to list blog authors", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Render the full list page
	return c.Render(http.StatusOK, "admin/pages/blog_authors_list.html", map[string]interface{}{
		"Title": "Blog Authors",
		"Items": items,
	})
}

// New handles GET /admin/blog-authors/new
// Renders the create blog author form with empty fields.
// Template: admin/pages/blog_authors_form.html (full page)
// Form fields include name, title, bio, avatar_url, linkedin_url, email, and sort_order.
func (h *BlogAuthorsHandler) New(c echo.Context) error {
	return c.Render(http.StatusOK, "admin/pages/blog_authors_form.html", map[string]interface{}{
		"Title":      "New Blog Author",
		"FormAction": "/admin/blog-authors",
		"Item":       nil, // No existing author data
	})
}

// Create handles POST /admin/blog-authors
// Processes the blog author creation form submission.
// Auto-generates slug from name. Optional fields (bio, avatar, linkedin, email) use sql.NullString.
// Redirects to /admin/blog-authors on success.
func (h *BlogAuthorsHandler) Create(c echo.Context) error {
	// Parse sort_order and optional fields from form
	sortOrder, _ := strconv.ParseInt(c.FormValue("sort_order"), 10, 64)
	bio := c.FormValue("bio")
	avatarUrl := c.FormValue("avatar_url")
	linkedinUrl := c.FormValue("linkedin_url")
	email := c.FormValue("email")

	// Insert the blog author into the database
	// Slug is auto-generated from name using makeSlug utility function
	_, err := h.queries.CreateBlogAuthor(c.Request().Context(), sqlc.CreateBlogAuthorParams{
		Name:        c.FormValue("name"),
		Slug:        makeSlug(c.FormValue("name")), // Auto-generate URL-friendly slug
		Title:       c.FormValue("title"),
		Bio:         sql.NullString{String: bio, Valid: bio != ""},                     // NULL if empty
		AvatarUrl:   sql.NullString{String: avatarUrl, Valid: avatarUrl != ""},         // NULL if empty
		LinkedinUrl: sql.NullString{String: linkedinUrl, Valid: linkedinUrl != ""},     // NULL if empty
		Email:       sql.NullString{String: email, Valid: email != ""},                 // NULL if empty
		SortOrder:   sortOrder,
	})
	if err != nil {
		h.logger.Error("failed to create blog author", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the creation activity for audit trail
	logActivity(c, "created", "blog_author", 0, c.FormValue("name"), "Created blog_author '%s'", c.FormValue("name"))
	return c.Redirect(http.StatusSeeOther, "/admin/blog-authors")
}

// Edit handles GET /admin/blog-authors/:id/edit
// Renders the edit blog author form pre-filled with existing author data.
// Template: admin/pages/blog_authors_form.html (full page)
// Returns 404 if author ID does not exist.
func (h *BlogAuthorsHandler) Edit(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch the existing author or return 404 if not found
	item, err := h.queries.GetBlogAuthor(c.Request().Context(), id)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound, "Author not found")
	}

	// Render form with existing author data pre-filled
	return c.Render(http.StatusOK, "admin/pages/blog_authors_form.html", map[string]interface{}{
		"Title":      "Edit Blog Author",
		"FormAction": "/admin/blog-authors/" + c.Param("id"),
		"Item":       item, // Existing author data
	})
}

// Update handles POST /admin/blog-authors/:id
// Processes the blog author update form submission.
// Regenerates slug from name on each update. Optional fields use sql.NullString.
// Redirects to /admin/blog-authors on success.
func (h *BlogAuthorsHandler) Update(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Parse form values (same as Create handler)
	sortOrder, _ := strconv.ParseInt(c.FormValue("sort_order"), 10, 64)
	bio := c.FormValue("bio")
	avatarUrl := c.FormValue("avatar_url")
	linkedinUrl := c.FormValue("linkedin_url")
	email := c.FormValue("email")

	// Update the blog author in the database
	// Slug is regenerated from name on each update
	_, err := h.queries.UpdateBlogAuthor(c.Request().Context(), sqlc.UpdateBlogAuthorParams{
		ID:          id,
		Name:        c.FormValue("name"),
		Slug:        makeSlug(c.FormValue("name")), // Regenerate slug from updated name
		Title:       c.FormValue("title"),
		Bio:         sql.NullString{String: bio, Valid: bio != ""},                     // NULL if empty
		AvatarUrl:   sql.NullString{String: avatarUrl, Valid: avatarUrl != ""},         // NULL if empty
		LinkedinUrl: sql.NullString{String: linkedinUrl, Valid: linkedinUrl != ""},     // NULL if empty
		Email:       sql.NullString{String: email, Valid: email != ""},                 // NULL if empty
		SortOrder:   sortOrder,
	})
	if err != nil {
		h.logger.Error("failed to update blog author", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the update activity for audit trail
	logActivity(c, "updated", "blog_author", id, c.FormValue("name"), "Updated blog_author '%s'", c.FormValue("name"))
	return c.Redirect(http.StatusSeeOther, "/admin/blog-authors")
}

// Delete handles DELETE /admin/blog-authors/:id
// Deletes a blog author from the database.
// HTMX behavior: Returns 200 OK with no content, triggering client-side row removal.
// Note: May fail if author is referenced by existing blog posts (foreign key constraint).
func (h *BlogAuthorsHandler) Delete(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Attempt to delete the author
	// Will fail if author is referenced by blog posts due to foreign key constraints
	if err := h.queries.DeleteBlogAuthor(c.Request().Context(), id); err != nil {
		h.logger.Error("failed to delete blog author", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the deletion activity for audit trail
	logActivity(c, "deleted", "blog_author", id, "", "Deleted blog_author #%d", id)

	// Return empty 200 OK response for HTMX to process
	return c.NoContent(http.StatusOK)
}
