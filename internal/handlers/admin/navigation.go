// Package admin provides HTTP handlers for the admin panel's navigation management functionality.
// This file handles CRUD operations for navigation menus and their items, including hierarchical
// menu structures with parent-child relationships, drag-and-drop reordering, and multiple menu locations.
package admin

import (
	// Standard library imports
	"database/sql"    // SQL null types for optional database fields
	"encoding/json"   // JSON encoding/decoding for AJAX requests
	"fmt"             // String formatting for dynamic URLs and messages
	"log/slog"        // Structured logging for error and debug output
	"net/http"        // HTTP status codes and request/response handling
	"strconv"         // String to integer conversion for parsing IDs

	// Third-party framework
	"github.com/labstack/echo/v4" // Echo web framework for routing and context handling

	// Internal imports
	"github.com/narendhupati/bluejay-cms/db/sqlc" // Database query layer generated by sqlc
)

// NavigationHandler manages navigation menus and menu items for the website.
// It supports multiple menus (header, footer, sidebar), hierarchical menu structures
// with parent-child relationships, drag-and-drop reordering, and various link types.
type NavigationHandler struct {
	queries *sqlc.Queries // Database query interface for navigation operations
	logger  *slog.Logger  // Structured logger for error tracking
}

// NewNavigationHandler creates and initializes a new NavigationHandler instance.
// It requires database queries interface and a logger for operation tracking.
//
// Parameters:
//   - queries: Database query layer for executing navigation operations
//   - logger: Structured logger for error and activity logging
//
// Returns a fully initialized NavigationHandler ready to handle HTTP requests.
func NewNavigationHandler(queries *sqlc.Queries, logger *slog.Logger) *NavigationHandler {
	return &NavigationHandler{queries: queries, logger: logger}
}

// NavigationItemView is a template-friendly struct that includes child navigation items.
// It embeds the base NavigationItem and adds a Children slice to represent hierarchical
// menu structures (e.g., dropdown menus with parent and child items).
type NavigationItemView struct {
	sqlc.NavigationItem               // Embedded base navigation item (ID, Label, URL, etc.)
	Children            []sqlc.NavigationItem // Child items for dropdown/nested menus
}

// List renders the navigation menus overview page showing all available menus.
//
// HTTP Method: GET
// Route: /admin/navigation
// HTMX: Returns full page (not a fragment)
// Template: admin/pages/navigation_list.html
//
// This handler displays a list of all navigation menus configured in the system.
// Each menu shows its name, location (header/footer/sidebar), and item count.
// Users can click on a menu to edit it, create new menus, or delete existing menus.
//
// The handler calculates item counts for each menu to provide quick overview statistics
// without requiring the user to open each menu.
//
// Returns:
//   - 200 OK with rendered HTML list on success
//   - 500 Internal Server Error if database query fails
func (h *NavigationHandler) List(c echo.Context) error {
	ctx := c.Request().Context()

	// Retrieve all navigation menus from the database
	menus, err := h.queries.ListNavigationMenus(ctx)
	if err != nil {
		h.logger.Error("failed to list navigation menus", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Count items per menu for display in the overview
	// This provides quick statistics without loading full item details
	menuItemCounts := make(map[int64]int)
	for _, menu := range menus {
		items, err := h.queries.ListNavigationItems(ctx, menu.ID)
		if err == nil {
			menuItemCounts[menu.ID] = len(items) // Store count by menu ID
		}
		// Silently skip menus that fail to load items (won't show count)
	}

	// Render the menus list page
	return c.Render(http.StatusOK, "admin/pages/navigation_list.html", map[string]interface{}{
		"Title":          "Navigation Menus",
		"Menus":          menus,          // All menu records
		"MenuItemCounts": menuItemCounts, // Item counts indexed by menu ID
	})
}

// Edit renders the navigation menu editor page with hierarchical item management.
//
// HTTP Method: GET
// Route: /admin/navigation/:id
// HTMX: Returns full page (not a fragment)
// Template: admin/pages/navigation_editor.html
//
// This handler displays a detailed editor for a specific navigation menu. It shows:
//   - Menu metadata (name, location)
//   - Hierarchical list of menu items (parents and children)
//   - Ability to add, edit, delete, and reorder items
//   - Drag-and-drop interface for reordering items
//
// The handler organizes flat menu items into a hierarchical tree structure for display.
// Items without a parent_id are top-level, while items with parent_id are children
// (rendered as dropdown/submenu items in the frontend).
//
// URL Parameters:
//   - id: Navigation menu ID to edit
//
// Query Parameters:
//   - saved: Set to "1" to display a success message
//
// Returns:
//   - 200 OK with rendered HTML editor on success
//   - 400 Bad Request if ID is invalid
//   - 404 Not Found if menu doesn't exist
//   - 500 Internal Server Error if database query fails
func (h *NavigationHandler) Edit(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse menu ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest)
	}

	// Retrieve menu record
	menu, err := h.queries.GetNavigationMenu(ctx, id)
	if err != nil {
		h.logger.Error("failed to get navigation menu", "error", err)
		return echo.NewHTTPError(http.StatusNotFound)
	}

	// Retrieve all items belonging to this menu
	items, err := h.queries.ListNavigationItems(ctx, id)
	if err != nil {
		h.logger.Error("failed to list navigation items", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Build hierarchical tree structure from flat item list
	// Step 1: Create a map of parent items to their children
	topLevel := []NavigationItemView{}
	childrenMap := make(map[int64][]sqlc.NavigationItem)
	for _, item := range items {
		if item.ParentID.Valid {
			// Item has a parent, add it to children map
			childrenMap[item.ParentID.Int64] = append(childrenMap[item.ParentID.Int64], item)
		}
	}

	// Step 2: Build top-level items with their children attached
	for _, item := range items {
		if !item.ParentID.Valid {
			// Top-level item (no parent), attach any children from map
			topLevel = append(topLevel, NavigationItemView{
				NavigationItem: item,
				Children:       childrenMap[item.ID], // May be nil if no children
			})
		}
	}

	// Check if this is a redirect after successful save operation
	saved := c.QueryParam("saved") == "1"

	// Predefined page options for quick link creation (internal CMS pages)
	pageOptions := []string{
		"Products", "Solutions", "About", "Blog", "Case Studies",
		"Whitepapers", "Partners", "Contact",
	}

	// Render the navigation editor with organized data
	return c.Render(http.StatusOK, "admin/pages/navigation_editor.html", map[string]interface{}{
		"Title":       fmt.Sprintf("Edit Menu: %s", menu.Name),
		"Menu":        menu,        // Menu metadata
		"Items":       topLevel,    // Hierarchical items for tree rendering
		"AllItems":    items,       // Flat list of all items (for dropdown parent selection)
		"Saved":       saved,       // Success flag
		"PageOptions": pageOptions, // Predefined internal page options
	})
}

// Create handles creation of a new navigation menu.
//
// HTTP Method: POST
// Route: /admin/navigation/create
// HTMX: Not used for this endpoint (standard form POST)
// Template: None (redirects to Edit handler)
//
// This handler creates a new navigation menu with a name and location.
// After creation, it redirects to the menu editor where items can be added.
//
// Form Fields:
//   - name: Menu name (defaults to "New Menu" if empty)
//   - location: Menu location - "header", "footer", or "sidebar" (defaults to "header")
//
// Returns:
//   - 303 See Other redirect to /admin/navigation/:id?saved=1 on success
//   - 500 Internal Server Error if database operation fails
func (h *NavigationHandler) Create(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse form values with defaults
	name := c.FormValue("name")
	location := c.FormValue("location")

	if name == "" {
		name = "New Menu" // Default name for empty submissions
	}
	if location == "" {
		location = "header" // Default to header menu
	}

	// Create menu record in database
	menu, err := h.queries.CreateNavigationMenu(ctx, sqlc.CreateNavigationMenuParams{
		Name:     name,
		Location: location,
	})
	if err != nil {
		h.logger.Error("failed to create navigation menu", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the creation activity for audit trail
	logActivity(c, "created", "navigation", 0, c.FormValue("name"), "Created Navigation Menu '%s'", c.FormValue("name"))

	// Redirect to the menu editor for the newly created menu
	return c.Redirect(http.StatusSeeOther, fmt.Sprintf("/admin/navigation/%d?saved=1", menu.ID))
}

// DeleteMenu handles deletion of a navigation menu and all its items.
//
// HTTP Method: DELETE
// Route: /admin/navigation/:id
// HTMX: Returns 204 No Content (used with AJAX delete requests)
// Template: None (returns empty response)
//
// This handler performs cascading deletion: first deletes all menu items
// belonging to the menu, then deletes the menu itself. This ensures referential
// integrity and prevents orphaned menu items.
//
// URL Parameters:
//   - id: Navigation menu ID to delete
//
// Returns:
//   - 204 No Content on successful deletion
//   - 400 Bad Request if ID is invalid
//   - 500 Internal Server Error if deletion fails
func (h *NavigationHandler) DeleteMenu(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse menu ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest)
	}

	// Delete all items belonging to this menu first (cascading delete)
	// This prevents foreign key constraint violations
	if err := h.queries.DeleteNavigationItemsByMenu(ctx, id); err != nil {
		h.logger.Error("failed to delete navigation items", "error", err)
		// Continue to attempt menu deletion even if items fail
	}

	// Delete the menu record itself
	if err := h.queries.DeleteNavigationMenu(ctx, id); err != nil {
		h.logger.Error("failed to delete navigation menu", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the deletion activity for audit trail
	logActivity(c, "deleted", "navigation", id, "", "Deleted Navigation Menu #%d", id)

	// Return 204 No Content (standard for successful DELETE with no response body)
	return c.NoContent(http.StatusOK)
}

// AddItem handles creation of a new navigation menu item.
//
// HTTP Method: POST
// Route: /admin/navigation/:id/items
// HTMX: Not used for this endpoint (standard form POST)
// Template: None (redirects to Edit handler)
//
// This handler creates a new menu item and adds it to the specified menu.
// It supports different link types:
//   - "page": Internal CMS page (auto-generates URL from page identifier)
//   - "url": Custom URL (internal or external)
//   - "dropdown": Parent item for dropdown menus (no URL)
//
// The handler automatically assigns the next available sort order to place
// the new item at the end of the menu.
//
// URL Parameters:
//   - id: Navigation menu ID to add item to
//
// Form Fields:
//   - label: Display text for the menu item (defaults to "New Item")
//   - link_type: Type of link - "page", "url", or "dropdown" (defaults to "page")
//   - url: URL for "url" type links
//   - page_identifier: Page name for "page" type links (e.g., "Products", "About")
//
// Returns:
//   - 303 See Other redirect to /admin/navigation/:id?saved=1 on success
//   - 400 Bad Request if menu ID is invalid
//   - 500 Internal Server Error if database operation fails
func (h *NavigationHandler) AddItem(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse menu ID from URL parameter
	menuID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest)
	}

	// Parse form values
	label := c.FormValue("label")
	linkType := c.FormValue("link_type")
	url := c.FormValue("url")
	pageIdentifier := c.FormValue("page_identifier")

	// Apply defaults for empty values
	if label == "" {
		label = "New Item"
	}
	if linkType == "" {
		linkType = "page" // Default to internal page link
	}

	// Get current menu items to calculate next sort order
	// New items are appended to the end of the menu
	items, _ := h.queries.ListNavigationItems(ctx, menuID)
	nextSort := int64(len(items))

	// For "page" type links, auto-generate URL from page identifier
	// This ensures consistent internal linking (e.g., "Products" -> "/products")
	if linkType == "page" && pageIdentifier != "" && url == "" {
		url = "/" + slugifyNav(pageIdentifier) // Convert "Case Studies" to "/case-studies"
		label = pageIdentifier                 // Use page name as label if not provided
	}

	// Create the navigation item record
	_, err = h.queries.CreateNavigationItem(ctx, sqlc.CreateNavigationItemParams{
		MenuID:         menuID,
		Label:          label,
		LinkType:       linkType,
		Url:            sql.NullString{String: url, Valid: url != ""},                     // Empty URL is valid for dropdowns
		PageIdentifier: sql.NullString{String: pageIdentifier, Valid: pageIdentifier != ""}, // Only for "page" type
		OpenNewTab:     sql.NullInt64{Int64: 0, Valid: true},                              // Default: open in same tab
		IsActive:       sql.NullInt64{Int64: 1, Valid: true},                              // Default: active/visible
		SortOrder:      sql.NullInt64{Int64: nextSort, Valid: true},                       // Append to end
	})
	if err != nil {
		h.logger.Error("failed to create navigation item", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the update activity for audit trail
	logActivity(c, "updated", "navigation", 0, "", "Updated Navigation Items")

	// Redirect back to the menu editor
	return c.Redirect(http.StatusSeeOther, fmt.Sprintf("/admin/navigation/%d?saved=1", menuID))
}

// UpdateItem handles updates to an existing navigation menu item.
//
// HTTP Method: POST
// Route: /admin/navigation/items/:id
// HTMX: Not used for this endpoint (standard form POST)
// Template: None (redirects to Edit handler)
//
// This handler updates all editable fields of a menu item except ParentID and SortOrder,
// which are managed separately through the drag-and-drop reorder functionality.
//
// URL Parameters:
//   - id: Navigation item ID to update
//
// Form Fields:
//   - label: Display text for the menu item
//   - link_type: Type of link - "page", "url", or "dropdown"
//   - url: URL for the link
//   - page_identifier: Internal page identifier for "page" type links
//   - open_new_tab: Checkbox - whether to open link in new tab
//   - is_active: Checkbox - whether item is visible in menu
//
// Returns:
//   - 303 See Other redirect to /admin/navigation/:menu_id?saved=1 on success
//   - 400 Bad Request if item ID is invalid
//   - 404 Not Found if item doesn't exist
//   - 500 Internal Server Error if database operation fails
func (h *NavigationHandler) UpdateItem(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse item ID from URL parameter
	itemID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest)
	}

	// Retrieve current item to preserve ParentID and SortOrder
	item, err := h.queries.GetNavigationItem(ctx, itemID)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	// Parse form values
	label := c.FormValue("label")
	linkType := c.FormValue("link_type")
	url := c.FormValue("url")
	pageIdentifier := c.FormValue("page_identifier")
	openNewTab := c.FormValue("open_new_tab") == "on" // Checkbox to boolean
	isActive := c.FormValue("is_active") == "on"       // Checkbox to boolean

	// Convert booleans to int64 for SQLite storage
	var openNewTabInt int64
	if openNewTab {
		openNewTabInt = 1
	}
	var isActiveInt int64
	if isActive {
		isActiveInt = 1
	}

	// Update the navigation item
	// Note: ParentID and SortOrder are preserved from existing item
	// These are managed separately through the Reorder endpoint
	err = h.queries.UpdateNavigationItem(ctx, sqlc.UpdateNavigationItemParams{
		ID:             itemID,
		Label:          label,
		LinkType:       linkType,
		Url:            sql.NullString{String: url, Valid: url != ""},
		PageIdentifier: sql.NullString{String: pageIdentifier, Valid: pageIdentifier != ""},
		OpenNewTab:     sql.NullInt64{Int64: openNewTabInt, Valid: true},
		IsActive:       sql.NullInt64{Int64: isActiveInt, Valid: true},
		ParentID:       item.ParentID,  // Preserve existing parent relationship
		SortOrder:      item.SortOrder, // Preserve existing sort position
	})
	if err != nil {
		h.logger.Error("failed to update navigation item", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the update activity for audit trail
	logActivity(c, "updated", "navigation", 0, "", "Updated Navigation Items")

	// Redirect back to the menu editor
	return c.Redirect(http.StatusSeeOther, fmt.Sprintf("/admin/navigation/%d?saved=1", item.MenuID))
}

// DeleteItem handles deletion of a navigation menu item.
//
// HTTP Method: DELETE
// Route: /admin/navigation/items/:id
// HTMX: Returns 204 No Content (used with AJAX delete requests)
// Template: None (returns empty response)
//
// This handler deletes a single navigation item. If the deleted item is a parent
// item with children, the children are not automatically deleted (they become orphaned).
// The frontend should prevent deletion of parent items that have children, or provide
// a warning to the user.
//
// URL Parameters:
//   - id: Navigation item ID to delete
//
// Returns:
//   - 204 No Content on successful deletion
//   - 400 Bad Request if ID is invalid
//   - 500 Internal Server Error if deletion fails
func (h *NavigationHandler) DeleteItem(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse item ID from URL parameter
	itemID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest)
	}

	// Delete the navigation item
	// Note: This does not cascade to children (they would become orphaned)
	if err := h.queries.DeleteNavigationItem(ctx, itemID); err != nil {
		h.logger.Error("failed to delete navigation item", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the update activity for audit trail
	logActivity(c, "updated", "navigation", 0, "", "Updated Navigation Items")

	// Return 204 No Content (standard for successful DELETE with no response body)
	return c.NoContent(http.StatusOK)
}

// Reorder handles drag-and-drop reordering of navigation menu items.
//
// HTTP Method: POST
// Route: /admin/navigation/reorder
// HTMX: Returns JSON response (used with JavaScript drag-and-drop)
// Template: None (returns JSON)
//
// This handler accepts a JSON array of items with their new sort order and parent relationships.
// It's called by the frontend drag-and-drop interface when users rearrange menu items.
// The handler updates both sort order and parent_id, allowing items to be:
//   - Reordered within the same level
//   - Moved into or out of dropdown/submenu groups
//   - Promoted from child to top-level or vice versa
//
// Request Body (JSON):
//   [{
//     "id": 123,
//     "parent_id": 456,  // null for top-level items
//     "order": 0
//   }, ...]
//
// Returns:
//   - 200 OK with {"status": "ok"} on success
//   - 400 Bad Request if JSON is invalid
//
// Note: Errors updating individual items are logged but don't fail the entire operation.
func (h *NavigationHandler) Reorder(c echo.Context) error {
	ctx := c.Request().Context()

	// Define structure for JSON request body
	type ReorderItem struct {
		ID       int64  `json:"id"`        // Navigation item ID
		ParentID *int64 `json:"parent_id"` // Parent item ID (null for top-level)
		Order    int64  `json:"order"`     // New sort order (0-based index)
	}

	// Parse JSON array from request body
	var items []ReorderItem
	if err := json.NewDecoder(c.Request().Body).Decode(&items); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "invalid JSON")
	}

	// Update each item with its new position and parent relationship
	for _, item := range items {
		// Convert nullable parent ID to sql.NullInt64
		parentID := sql.NullInt64{}
		if item.ParentID != nil {
			parentID = sql.NullInt64{Int64: *item.ParentID, Valid: true}
		}
		// If ParentID is nil, Valid is false, representing a top-level item

		// Update item's sort order and parent relationship
		err := h.queries.UpdateNavigationItemOrder(ctx, sqlc.UpdateNavigationItemOrderParams{
			ID:        item.ID,
			SortOrder: sql.NullInt64{Int64: item.Order, Valid: true},
			ParentID:  parentID,
		})
		if err != nil {
			// Log error but continue processing other items
			// This prevents one failure from blocking all reordering
			h.logger.Error("failed to reorder navigation item", "error", err, "id", item.ID)
		}
	}

	// Return success response
	return c.JSON(http.StatusOK, map[string]string{"status": "ok"})
}

// UpdateMenu handles updates to navigation menu metadata (name and location).
//
// HTTP Method: POST
// Route: /admin/navigation/:id/update
// HTMX: Not used for this endpoint (standard form POST)
// Template: None (redirects to Edit handler)
//
// This handler updates the menu's name and location without affecting its items.
//
// URL Parameters:
//   - id: Navigation menu ID to update
//
// Form Fields:
//   - name: Menu name
//   - location: Menu location - "header", "footer", or "sidebar"
//
// Returns:
//   - 303 See Other redirect to /admin/navigation/:id?saved=1 on success
//   - 400 Bad Request if ID is invalid
//   - 500 Internal Server Error if database operation fails
func (h *NavigationHandler) UpdateMenu(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse menu ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest)
	}

	// Parse form values
	name := c.FormValue("name")
	location := c.FormValue("location")

	// Update menu metadata
	err = h.queries.UpdateNavigationMenu(ctx, sqlc.UpdateNavigationMenuParams{
		ID:       id,
		Name:     name,
		Location: location,
	})
	if err != nil {
		h.logger.Error("failed to update navigation menu", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the update activity for audit trail
	logActivity(c, "updated", "navigation", id, c.FormValue("name"), "Updated Navigation Menu '%s'", c.FormValue("name"))

	// Redirect back to the menu editor
	return c.Redirect(http.StatusSeeOther, fmt.Sprintf("/admin/navigation/%d?saved=1", id))
}

// slugifyNav converts a human-readable page identifier into a URL-safe slug.
// It performs the following transformations:
//   - Converts uppercase letters to lowercase
//   - Converts spaces to hyphens
//   - Preserves alphanumeric characters and hyphens
//   - Removes all other special characters
//
// Examples:
//   - "Case Studies" -> "case-studies"
//   - "About Us" -> "about-us"
//   - "Products & Services" -> "products--services"
//
// This function is used when creating navigation items of type "page" to automatically
// generate consistent internal URLs from page identifiers.
func slugifyNav(s string) string {
	result := ""
	for _, c := range s {
		if c >= 'a' && c <= 'z' || c >= '0' && c <= '9' || c == '-' {
			// Keep lowercase letters, numbers, and hyphens as-is
			result += string(c)
		} else if c >= 'A' && c <= 'Z' {
			// Convert uppercase to lowercase (ASCII: A=65, a=97, difference=32)
			result += string(c + 32)
		} else if c == ' ' {
			// Convert spaces to hyphens
			result += "-"
		}
		// All other characters are silently dropped
	}
	return result
}
