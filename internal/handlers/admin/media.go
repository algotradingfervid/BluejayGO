// Package admin provides HTTP handlers for the admin panel's media library functionality.
// This file handles file upload, storage, retrieval, and management of media files including
// images (JPEG, PNG, GIF, WebP, SVG), PDFs, and other supported file types.
package admin

import (
	// Standard library imports
	"database/sql"    // SQL null types for optional database fields
	"encoding/json"   // JSON encoding for API responses
	"fmt"             // String formatting for file naming and messages
	"image"           // Image configuration decoding for dimensions
	_ "image/gif"     // GIF format support (imported for side-effects, registers decoder)
	_ "image/jpeg"    // JPEG format support (imported for side-effects, registers decoder)
	_ "image/png"     // PNG format support (imported for side-effects, registers decoder)
	"io"              // I/O operations for file copying
	"log/slog"        // Structured logging for error and debug output
	"mime/multipart"  // Multipart form data handling for file uploads
	"net/http"        // HTTP status codes and request/response handling
	"os"              // File system operations (create, remove directories/files)
	"path/filepath"   // File path manipulation and joining
	"strconv"         // String to integer conversion for parsing IDs and page numbers
	"strings"         // String manipulation for path processing
	"time"            // Time operations for unique filename generation

	// Third-party framework
	"github.com/labstack/echo/v4" // Echo web framework for routing and context handling

	// Internal imports
	"github.com/narendhupati/bluejay-cms/db/sqlc"                   // Database query layer generated by sqlc
	customMiddleware "github.com/narendhupati/bluejay-cms/internal/middleware" // Session middleware for user info
)

// MediaHandler manages media library functionality for file uploads and organization.
// It handles file uploads, storage, metadata tracking, search, pagination, and deletion.
// Supports multiple file types with validation, dimension detection, and alt text management.
type MediaHandler struct {
	queries   *sqlc.Queries // Database query interface for media operations
	logger    *slog.Logger  // Structured logger for error tracking
	uploadDir string        // Base directory for file storage (e.g., "public/uploads")
}

// NewMediaHandler creates and initializes a new MediaHandler instance.
// It requires database queries interface, a logger, and the upload directory path.
//
// Parameters:
//   - queries: Database query layer for executing media operations
//   - logger: Structured logger for error and activity logging
//   - uploadDir: Base directory for file storage (must be writable)
//
// Returns a fully initialized MediaHandler ready to handle HTTP requests.
func NewMediaHandler(queries *sqlc.Queries, logger *slog.Logger, uploadDir string) *MediaHandler {
	return &MediaHandler{
		queries:   queries,
		logger:    logger,
		uploadDir: uploadDir,
	}
}

// mediaPerPage defines the number of media files displayed per page in the library grid.
// This constant is used for pagination calculations across all media list views.
const mediaPerPage = 24

// List renders the main media library page with grid view of all media files.
//
// HTTP Method: GET
// Route: /admin/media
// HTMX: Returns full page (not a fragment)
// Template: admin/pages/media_library.html
//
// This handler displays a paginated, sortable, searchable grid of media files.
// It supports:
//   - Search by filename or alt text
//   - Sort by newest, oldest, name, or file size
//   - Pagination (24 files per page)
//   - File metadata display (dimensions, size, type)
//
// Query Parameters:
//   - search: Search term to filter files by filename or alt text
//   - sort: Sort order - "newest" (default), "oldest", "name", "largest"
//   - page: Page number (1-based, defaults to 1)
//
// The handler executes different database queries based on search and sort parameters
// to optimize performance.
//
// Returns:
//   - 200 OK with rendered HTML grid on success
//   - 500 Internal Server Error if database query fails
func (h *MediaHandler) List(c echo.Context) error {
	// Parse query parameters
	search := c.QueryParam("search")
	sort := c.QueryParam("sort")
	if sort == "" {
		sort = "newest" // Default sort order
	}
	page, _ := strconv.Atoi(c.QueryParam("page"))
	if page < 1 {
		page = 1 // Ensure valid page number
	}

	// Calculate database offset for pagination
	offset := int64((page - 1) * mediaPerPage)

	var files []sqlc.MediaFile
	var total int64
	var err error

	ctx := c.Request().Context()

	// Execute appropriate query based on search and sort parameters
	if search != "" {
		// Search mode: filter by filename or alt text
		files, err = h.queries.SearchMediaFiles(ctx, sqlc.SearchMediaFilesParams{
			Search:     sql.NullString{String: search, Valid: true},
			PageLimit:  int64(mediaPerPage),
			PageOffset: offset,
		})
		if err != nil {
			h.logger.Error("failed to search media files", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to search media files")
		}
		// Get total count for search results (for pagination)
		total, err = h.queries.CountMediaFilesSearch(ctx, sql.NullString{String: search, Valid: true})
	} else {
		// Normal mode: list with sorting
		switch sort {
		case "oldest":
			// Sort by upload date ascending (oldest first)
			files, err = h.queries.ListMediaFilesOldest(ctx, sqlc.ListMediaFilesOldestParams{
				Limit: int64(mediaPerPage), Offset: offset,
			})
		case "name":
			// Sort alphabetically by filename
			files, err = h.queries.ListMediaFilesByName(ctx, sqlc.ListMediaFilesByNameParams{
				Limit: int64(mediaPerPage), Offset: offset,
			})
		case "largest":
			// Sort by file size descending (largest first)
			files, err = h.queries.ListMediaFilesBySize(ctx, sqlc.ListMediaFilesBySizeParams{
				Limit: int64(mediaPerPage), Offset: offset,
			})
		default:
			// Default: sort by upload date descending (newest first)
			files, err = h.queries.ListMediaFiles(ctx, sqlc.ListMediaFilesParams{
				Limit: int64(mediaPerPage), Offset: offset,
			})
		}
		if err != nil {
			h.logger.Error("failed to list media files", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to list media files")
		}
		// Get total count of all files (for pagination)
		total, err = h.queries.CountMediaFiles(ctx)
	}

	if err != nil {
		h.logger.Error("failed to count media files", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to count media files")
	}

	// Calculate total pages (round up division)
	totalPages := (total + int64(mediaPerPage) - 1) / int64(mediaPerPage)

	// Prepare template data
	data := map[string]interface{}{
		"Title":       "Media Library",
		"Files":       files,                  // Media file records for current page
		"Total":       total,                  // Total number of files (all pages)
		"Page":        page,                   // Current page number
		"TotalPages":  totalPages,             // Total number of pages
		"Search":      search,                 // Current search term (for preserving state)
		"Sort":        sort,                   // Current sort order (for preserving state)
		"HasFilters":  search != "",           // Whether filters are active (for UI state)
		"ActiveNav":   "media",                // Active navigation item identifier
		"DisplayName": getSessionDisplayName(c), // Current user's display name
		"Role":        getSessionRole(c),      // Current user's role
	}

	// Render the media library page
	return c.Render(http.StatusOK, "admin/pages/media_library.html", data)
}

// Upload handles multi-file upload to the media library.
//
// HTTP Method: POST
// Route: /admin/media/upload
// HTMX: Returns JSON response (used with JavaScript file upload widget)
// Template: None (returns JSON)
//
// This handler processes multiple file uploads simultaneously, performing:
//   - File type validation (only allowed extensions)
//   - File size validation (max 10MB per file)
//   - Unique filename generation (timestamp-based)
//   - Image dimension detection (for images)
//   - MIME type detection/assignment
//   - Physical file storage
//   - Database record creation
//
// The handler gracefully handles partial failures: if some files fail to upload,
// successful uploads are still processed and reported.
//
// Allowed file types: .jpg, .jpeg, .png, .gif, .svg, .pdf, .webp
// Max file size: 10MB per file
//
// Form Data:
//   - files: Multiple files (using standard multipart/form-data)
//
// Returns:
//   - 200 OK with JSON list of uploaded files on success
//   - 400 Bad Request if no files provided or form data is invalid
//   - 500 Internal Server Error if upload directory creation fails
//
// Response JSON:
//   {
//     "files": [MediaFile, ...],
//     "count": 3,
//     "message": "3 file(s) uploaded successfully"
//   }
func (h *MediaHandler) Upload(c echo.Context) error {
	// Parse multipart form data
	form, err := c.MultipartForm()
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid form data"})
	}

	// Get uploaded files array
	formFiles := form.File["files"]
	if len(formFiles) == 0 {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "No files provided"})
	}

	// Define allowed file extensions (whitelist approach for security)
	allowedTypes := map[string]bool{
		".jpg": true, ".jpeg": true, ".png": true, ".gif": true, ".svg": true, ".pdf": true, ".webp": true,
	}

	// Ensure upload directory exists (e.g., "public/uploads/media")
	mediaDir := filepath.Join(h.uploadDir, "media")
	if err := os.MkdirAll(mediaDir, 0755); err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create upload directory"})
	}

	var uploaded []sqlc.MediaFile
	ctx := c.Request().Context()

	// Process each uploaded file
	for _, file := range formFiles {
		// Validate file extension
		ext := strings.ToLower(filepath.Ext(file.Filename))
		if !allowedTypes[ext] {
			// Skip files with disallowed extensions (silently)
			continue
		}

		// Validate file size (max 10MB)
		if file.Size > 10*1024*1024 {
			// Skip files that are too large (silently)
			continue
		}

		// Generate unique filename using nanosecond timestamp to prevent collisions
		filename := fmt.Sprintf("%d_%s", time.Now().UnixNano(), sanitizeMediaFilename(file.Filename))
		webPath := "/uploads/media/" + filename         // Path for URLs in HTML
		dstPath := filepath.Join(mediaDir, filename) // Physical file system path

		// Extract image dimensions (returns 0,0 for non-images or errors)
		width, height := h.getImageDimensions(file)

		// Determine MIME type from header or extension
		mimeType := file.Header.Get("Content-Type")
		if mimeType == "" {
			mimeType = getMimeTypeFromExt(ext) // Fallback to extension-based lookup
		}

		// Open uploaded file for reading
		src, err := file.Open()
		if err != nil {
			h.logger.Error("failed to open uploaded file", "error", err)
			continue // Skip this file, continue with others
		}

		// Create destination file on disk
		dst, err := os.Create(dstPath)
		if err != nil {
			src.Close()
			h.logger.Error("failed to create destination file", "error", err)
			continue // Skip this file, continue with others
		}

		// Copy file contents from upload to destination
		if _, err = io.Copy(dst, src); err != nil {
			src.Close()
			dst.Close()
			h.logger.Error("failed to copy file", "error", err)
			continue // Skip this file, continue with others
		}
		src.Close()
		dst.Close()

		// Create database record for the uploaded file
		mediaFile, err := h.queries.CreateMediaFile(ctx, sqlc.CreateMediaFileParams{
			Filename:         filename,           // Unique filename on disk
			OriginalFilename: file.Filename,      // Original filename from user
			FilePath:         webPath,            // Web-accessible path
			FileSize:         file.Size,          // File size in bytes
			MimeType:         mimeType,           // MIME type (e.g., "image/jpeg")
			Width:            sql.NullInt64{Int64: int64(width), Valid: width > 0},   // Image width (null for non-images)
			Height:           sql.NullInt64{Int64: int64(height), Valid: height > 0}, // Image height (null for non-images)
			AltText:          sql.NullString{String: "", Valid: true},                // Empty alt text (can be edited later)
		})
		if err != nil {
			h.logger.Error("failed to save media file record", "error", err)
			continue // Skip this file, continue with others
		}

		// Add to successful uploads list
		uploaded = append(uploaded, mediaFile)
	}

	// Log upload activity if at least one file was successful
	if len(uploaded) > 0 {
		logActivity(c, "created", "media", 0, "", "Uploaded Media File")
	}

	// Return JSON response with uploaded file details
	return c.JSON(http.StatusOK, map[string]interface{}{
		"files":   uploaded, // Array of MediaFile records
		"count":   len(uploaded),
		"message": fmt.Sprintf("%d file(s) uploaded successfully", len(uploaded)),
	})
}

// GetFile retrieves metadata for a single media file.
//
// HTTP Method: GET
// Route: /admin/media/:id
// HTMX: Returns JSON response (used with AJAX requests from media picker)
// Template: None (returns JSON)
//
// This handler is used by the media picker modal and other components that need
// file metadata without rendering HTML.
//
// URL Parameters:
//   - id: Media file ID
//
// Returns:
//   - 200 OK with JSON MediaFile record on success
//   - 400 Bad Request if ID is invalid
//   - 404 Not Found if file doesn't exist
func (h *MediaHandler) GetFile(c echo.Context) error {
	// Parse file ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	// Retrieve file record from database
	file, err := h.queries.GetMediaFile(c.Request().Context(), id)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "File not found"})
	}

	// Return file metadata as JSON
	return c.JSON(http.StatusOK, file)
}

// UpdateAltText updates the alt text for an existing media file.
//
// HTTP Method: PUT or POST
// Route: /admin/media/:id/alt
// HTMX: Returns JSON response (used with inline alt text editor)
// Template: None (returns JSON)
//
// This handler updates the accessibility alt text for images. It accepts both
// JSON request body and form data for flexibility.
//
// URL Parameters:
//   - id: Media file ID
//
// Request Body (JSON or form data):
//   - alt_text: New alt text value
//
// Returns:
//   - 200 OK with success message on update
//   - 400 Bad Request if ID is invalid
//   - 500 Internal Server Error if database update fails
func (h *MediaHandler) UpdateAltText(c echo.Context) error {
	// Parse file ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	// Parse alt text from JSON body or form data
	var body struct {
		AltText string `json:"alt_text"`
	}
	if err := json.NewDecoder(c.Request().Body).Decode(&body); err != nil {
		// Fallback to form data if JSON parsing fails
		body.AltText = c.FormValue("alt_text")
	}

	// Update alt text in database
	err = h.queries.UpdateMediaFileAltText(c.Request().Context(), sqlc.UpdateMediaFileAltTextParams{
		AltText: sql.NullString{String: body.AltText, Valid: true},
		ID:      id,
	})
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to update alt text"})
	}

	// Return success response
	return c.JSON(http.StatusOK, map[string]string{"message": "Alt text updated"})
}

// Delete handles deletion of a media file from both database and file system.
//
// HTTP Method: DELETE
// Route: /admin/media/:id
// HTMX: Returns JSON response (used with AJAX delete requests)
// Template: None (returns JSON)
//
// This handler performs a complete cleanup:
//   1. Retrieves file metadata to get physical file path
//   2. Deletes physical file from disk
//   3. Deletes database record
//
// Note: Physical file deletion errors are silently ignored to ensure the database
// record is still removed even if the file is missing.
//
// URL Parameters:
//   - id: Media file ID to delete
//
// Returns:
//   - 200 OK with success message on deletion
//   - 400 Bad Request if ID is invalid
//   - 404 Not Found if file record doesn't exist
//   - 500 Internal Server Error if database deletion fails
func (h *MediaHandler) Delete(c echo.Context) error {
	// Parse file ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	// Retrieve file record to get physical file path
	file, err := h.queries.GetMediaFile(c.Request().Context(), id)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "File not found"})
	}

	// Delete physical file from disk
	// Convert web path ("/uploads/media/file.jpg") to file system path
	fsPath := filepath.Join(h.uploadDir, strings.TrimPrefix(file.FilePath, "/uploads/"))
	os.Remove(fsPath) // Ignore errors (file may already be deleted)

	// Delete database record
	if err := h.queries.DeleteMediaFile(c.Request().Context(), id); err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to delete file"})
	}

	// Log the deletion activity for audit trail
	logActivity(c, "deleted", "media", id, "", "Deleted Media File #%d", id)

	// Return success response
	return c.JSON(http.StatusOK, map[string]string{"message": "File deleted"})
}

// Browse renders the media picker modal partial for file selection.
//
// HTTP Method: GET
// Route: /admin/media/browse
// HTMX: Returns HTML fragment (used in modal dialogs)
// Template: admin/partials/media_picker.html
//
// This handler is used by the media picker modal component that appears when users
// click "Choose Image" buttons in forms. It provides a simplified, modal-friendly
// view of the media library with search and pagination.
//
// Unlike the main List handler, this returns a partial template designed to be
// embedded in a modal dialog rather than a full page.
//
// Query Parameters:
//   - search: Search term to filter files by filename or alt text
//   - page: Page number (1-based, defaults to 1)
//
// Returns:
//   - 200 OK with rendered HTML fragment on success
//   - 500 Internal Server Error if database query fails
func (h *MediaHandler) Browse(c echo.Context) error {
	// Parse query parameters
	search := c.QueryParam("search")
	page, _ := strconv.Atoi(c.QueryParam("page"))
	if page < 1 {
		page = 1 // Ensure valid page number
	}

	// Calculate database offset for pagination
	offset := int64((page - 1) * mediaPerPage)

	var files []sqlc.MediaFile
	var total int64
	var err error
	ctx := c.Request().Context()

	// Execute appropriate query based on search parameter
	if search != "" {
		// Search mode: filter by filename or alt text
		files, err = h.queries.SearchMediaFiles(ctx, sqlc.SearchMediaFilesParams{
			Search:     sql.NullString{String: search, Valid: true},
			PageLimit:  int64(mediaPerPage),
			PageOffset: offset,
		})
		if err == nil {
			// Get total count for search results (for pagination)
			total, err = h.queries.CountMediaFilesSearch(ctx, sql.NullString{String: search, Valid: true})
		}
	} else {
		// Normal mode: list all files (newest first)
		files, err = h.queries.ListMediaFiles(ctx, sqlc.ListMediaFilesParams{
			Limit: int64(mediaPerPage), Offset: offset,
		})
		if err == nil {
			// Get total count of all files (for pagination)
			total, err = h.queries.CountMediaFiles(ctx)
		}
	}

	if err != nil {
		h.logger.Error("failed to browse media files", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load media files")
	}

	// Calculate total pages (round up division)
	totalPages := (total + int64(mediaPerPage) - 1) / int64(mediaPerPage)

	// Prepare template data (minimal set for modal picker)
	data := map[string]interface{}{
		"Files":      files,      // Media file records for current page
		"Total":      total,      // Total number of files (all pages)
		"Page":       page,       // Current page number
		"TotalPages": totalPages, // Total number of pages
		"Search":     search,     // Current search term (for preserving state)
	}

	// Render the media picker partial (not a full page)
	return c.Render(http.StatusOK, "admin/partials/media_picker.html", data)
}

// getImageDimensions extracts width and height from an uploaded image file.
//
// This helper method attempts to decode the image configuration without fully
// decoding the image data, making it fast for dimension extraction.
//
// It returns (0, 0) for:
//   - SVG files (vector graphics have no fixed dimensions)
//   - PDF files (not images)
//   - Files that fail to decode
//   - Files that fail to open
//
// Parameters:
//   - file: Multipart file header from uploaded file
//
// Returns:
//   - width, height: Image dimensions in pixels, or (0, 0) if not applicable/error
func (h *MediaHandler) getImageDimensions(file *multipart.FileHeader) (int, int) {
	// Open uploaded file for reading
	src, err := file.Open()
	if err != nil {
		return 0, 0
	}
	defer src.Close()

	// Skip dimension detection for vector/document formats
	ext := strings.ToLower(filepath.Ext(file.Filename))
	if ext == ".svg" || ext == ".pdf" {
		return 0, 0 // These formats don't have fixed pixel dimensions
	}

	// Decode image configuration (lightweight operation, doesn't load full image)
	// The image package supports JPEG, PNG, GIF via imported decoders
	config, _, err := image.DecodeConfig(src)
	if err != nil {
		return 0, 0 // Return zero dimensions if decode fails
	}

	return config.Width, config.Height
}

// sanitizeMediaFilename cleans uploaded filenames for safe file system storage.
//
// Currently performs minimal sanitization by replacing spaces with underscores.
// This prevents issues with command-line tools and URLs that don't handle spaces well.
//
// Parameters:
//   - filename: Original filename from user upload
//
// Returns:
//   - Sanitized filename safe for file system storage
func sanitizeMediaFilename(filename string) string {
	// Replace spaces with underscores for cleaner URLs and file system paths
	filename = strings.ReplaceAll(filename, " ", "_")
	// Additional sanitization could be added here (e.g., removing special characters)
	return filename
}

// getMimeTypeFromExt returns the MIME type for a file extension.
//
// This function provides a fallback when the browser doesn't send a Content-Type
// header or sends an incorrect one. It uses a whitelist of allowed file types
// that matches the upload validation in the Upload handler.
//
// Parameters:
//   - ext: File extension including the dot (e.g., ".jpg", ".png")
//
// Returns:
//   - MIME type string, or "application/octet-stream" if extension is unknown
func getMimeTypeFromExt(ext string) string {
	// Map of allowed extensions to their MIME types
	types := map[string]string{
		".jpg":  "image/jpeg",
		".jpeg": "image/jpeg",
		".png":  "image/png",
		".gif":  "image/gif",
		".svg":  "image/svg+xml",
		".pdf":  "application/pdf",
		".webp": "image/webp",
	}

	if t, ok := types[ext]; ok {
		return t
	}

	// Default MIME type for unknown extensions (binary data)
	return "application/octet-stream"
}

// getSessionDisplayName retrieves the current user's display name from the session.
//
// This helper extracts user information from the Echo context that was set by
// the authentication middleware. It's used in templates to personalize the UI.
//
// Parameters:
//   - c: Echo context with session data
//
// Returns:
//   - User's display name, or "Admin" if session is not available
func getSessionDisplayName(c echo.Context) string {
	// Extract session from context (set by middleware)
	if sess, ok := c.Get("session").(*customMiddleware.Session); ok {
		return sess.DisplayName
	}
	// Fallback display name if session is missing
	return "Admin"
}

// getSessionRole retrieves the current user's role from the session.
//
// This helper extracts user role information from the Echo context for
// authorization checks and UI customization based on role.
//
// Parameters:
//   - c: Echo context with session data
//
// Returns:
//   - User's role string, or empty string if session is not available
func getSessionRole(c echo.Context) string {
	// Extract session from context (set by middleware)
	if sess, ok := c.Get("session").(*customMiddleware.Session); ok {
		return sess.Role
	}
	// Return empty string if session is missing
	return ""
}
