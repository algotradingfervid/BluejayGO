// Package admin provides HTTP handlers for the admin panel product management functionality.
// This file contains the main product CRUD operations including listing, creating, editing,
// updating, and deleting products in the CMS.
package admin

import (
	"database/sql"               // Used for nullable database types (sql.NullString, sql.NullInt64, sql.NullTime)
	"fmt"                        // Used for string formatting in template paths
	"log/slog"                   // Structured logging for error and debug messages
	"math"                       // Used for calculating pagination (math.Ceil)
	"net/http"                   // HTTP status codes and request/response handling
	"strconv"                    // String to integer conversion for form values and URL parameters
	"time"                       // Used for setting published_at timestamps

	"github.com/labstack/echo/v4"                      // Echo web framework for routing and context
	"github.com/narendhupati/bluejay-cms/db/sqlc"      // sqlc-generated database queries
	"github.com/narendhupati/bluejay-cms/internal/services" // Upload service for image handling and cache service for invalidation
)

// ProductsHandler handles HTTP requests for product management in the admin panel.
// It provides CRUD operations for products including listing with filters, creating,
// editing, updating, and deleting products. It also handles image uploads and cache invalidation.
type ProductsHandler struct {
	queries   *sqlc.Queries           // Database queries generated by sqlc
	logger    *slog.Logger            // Structured logger for error reporting
	uploadSvc *services.UploadService // Service for handling product image uploads
	cache     *services.Cache         // Cache service for invalidating product-related cached pages
}

// NewProductsHandler creates and returns a new ProductsHandler instance with the provided dependencies.
// This constructor is typically called during application initialization when wiring up handlers.
func NewProductsHandler(queries *sqlc.Queries, logger *slog.Logger, uploadSvc *services.UploadService, cache *services.Cache) *ProductsHandler {
	return &ProductsHandler{
		queries:   queries,
		logger:    logger,
		uploadSvc: uploadSvc,
		cache:     cache,
	}
}

// productsPerPage defines the number of products displayed per page in the admin list view.
// This constant is used to calculate pagination offset and total page count.
const productsPerPage = 15

// List handles GET requests to /admin/products
// Renders the main product list page with filtering, searching, and pagination support.
//
// Query Parameters:
//   - search: Text search across product name/SKU
//   - status: Filter by product status (draft/published)
//   - category: Filter by category ID
//   - page: Current page number (defaults to 1)
//
// Template: admin/pages/products_list.html (full page render)
// HTMX: This endpoint returns a full HTML page, not a fragment
func (h *ProductsHandler) List(c echo.Context) error {
	ctx := c.Request().Context()

	// Extract filter and pagination parameters from query string
	search := c.QueryParam("search")
	status := c.QueryParam("status")
	categoryStr := c.QueryParam("category")
	pageStr := c.QueryParam("page")

	// Parse category ID if provided
	var categoryID int64
	if categoryStr != "" {
		categoryID, _ = strconv.ParseInt(categoryStr, 10, 64)
	}

	// Parse page number and ensure it's at least 1
	page, _ := strconv.Atoi(pageStr)
	if page < 1 {
		page = 1
	}
	// Calculate database offset for pagination
	offset := int64((page - 1) * productsPerPage)

	// Build parameters for filtered product query
	filterParams := sqlc.ListProductsAdminFilteredParams{
		FilterStatus:   status,
		FilterCategory: categoryID,
		FilterSearch:   search,
		PageLimit:      productsPerPage,
		PageOffset:     offset,
	}

	// Fetch paginated product list with applied filters
	products, err := h.queries.ListProductsAdminFiltered(ctx, filterParams)
	if err != nil {
		h.logger.Error("failed to list products", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Get total count of products matching filters (for pagination calculation)
	total, err := h.queries.CountProductsAdminFiltered(ctx, sqlc.CountProductsAdminFilteredParams{
		FilterStatus:   status,
		FilterCategory: categoryID,
		FilterSearch:   search,
	})
	if err != nil {
		h.logger.Error("failed to count products", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Fetch all categories for the filter dropdown
	categories, err := h.queries.ListProductCategories(ctx)
	if err != nil {
		h.logger.Error("failed to list categories", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Calculate total number of pages (rounded up)
	totalPages := int(math.Ceil(float64(total) / float64(productsPerPage)))
	if totalPages < 1 {
		totalPages = 1
	}

	// Build array of page numbers for pagination UI
	var pages []int
	for i := 1; i <= totalPages; i++ {
		pages = append(pages, i)
	}

	// Calculate "Showing X to Y of Z" display values
	showFrom := offset + 1
	showTo := offset + int64(len(products))
	if total == 0 {
		showFrom = 0 // Don't show "Showing 1 to 0" when no results
	}

	// Determine if any filters are active (for UI indicator)
	hasFilters := search != "" || status != "" || categoryStr != ""

	// Build a lookup map for displaying category names in product rows
	categoryMap := make(map[int64]string)
	for _, cat := range categories {
		categoryMap[cat.ID] = cat.Name
	}

	return c.Render(http.StatusOK, "admin/pages/products_list.html", map[string]interface{}{
		"Title":       "Manage Products",
		"Products":    products,
		"Categories":  categories,
		"CategoryMap": categoryMap,
		"Search":      search,
		"Status":      status,
		"CategoryID":  categoryID,
		"HasFilters":  hasFilters,
		"Page":        page,
		"TotalPages":  totalPages,
		"Pages":       pages,
		"Total":       total,
		"ShowFrom":    showFrom,
		"ShowTo":      showTo,
	})
}

// New handles GET requests to /admin/products/new
// Renders the product creation form with all necessary data.
//
// Template: admin/pages/products_form.html (full page render)
// HTMX: This endpoint returns a full HTML page, not a fragment
//
// The form includes fields for product details, category selection, image upload,
// featured status, SEO metadata, and status (draft/published).
func (h *ProductsHandler) New(c echo.Context) error {
	// Fetch all categories to populate the category dropdown
	categories, err := h.queries.ListProductCategories(c.Request().Context())
	if err != nil {
		h.logger.Error("failed to list categories", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}
	// Render the form template with no existing item (Item: nil indicates new product)
	return c.Render(http.StatusOK, "admin/pages/products_form.html", map[string]interface{}{
		"Title":      "New Product",
		"FormAction": "/admin/products",       // POST to this endpoint for creation
		"Item":       nil,                     // No existing product data
		"Categories": categories,              // Available categories for dropdown
	})
}

// Create handles POST requests to /admin/products
// Processes the product creation form submission and saves the new product to the database.
//
// Form Fields:
//   - sku, name, description: Required product details
//   - category_id: Foreign key to product category
//   - tagline, overview: Optional marketing text
//   - primary_image: Optional file upload for product image
//   - is_featured: Checkbox (value "1" if checked)
//   - featured_order: Display order for featured products
//   - meta_title, meta_description: SEO fields
//   - video_url: Optional video embed URL
//   - status: "draft" or "published"
//
// On Success: Redirects to /admin/products (HTTP 303 See Other)
// On Error: Returns HTTP error with appropriate status code
//
// Side Effects:
//   - Uploads image to disk/storage if provided
//   - Sets published_at timestamp if status is "published"
//   - Invalidates product page cache
//   - Logs activity to audit trail
func (h *ProductsHandler) Create(c echo.Context) error {
	ctx := c.Request().Context()

	// Parse integer and boolean form values
	categoryID, _ := strconv.ParseInt(c.FormValue("category_id"), 10, 64)
	isFeatured := c.FormValue("is_featured") == "1" // Checkbox sends "1" if checked
	featuredOrder, _ := strconv.ParseInt(c.FormValue("featured_order"), 10, 64)

	// Extract optional text fields
	tagline := c.FormValue("tagline")
	overview := c.FormValue("overview")
	metaTitle := c.FormValue("meta_title")
	metaDesc := c.FormValue("meta_description")
	videoURL := c.FormValue("video_url")

	// Handle optional primary image upload
	var imagePath sql.NullString
	if fileHeader, err := c.FormFile("primary_image"); err == nil {
		// Image file was provided, upload it
		path, err := h.uploadSvc.UploadProductImage(fileHeader)
		if err != nil {
			h.logger.Error("failed to upload image", "error", err)
			return echo.NewHTTPError(http.StatusBadRequest, "Failed to upload image: "+err.Error())
		}
		imagePath = sql.NullString{String: path, Valid: true}
	}

	// Set published_at timestamp if product is being published
	status := c.FormValue("status")
	var publishedAt sql.NullTime
	if status == "published" {
		publishedAt = sql.NullTime{Time: time.Now(), Valid: true}
	}

	// Insert new product into database with all fields
	// Note: Slug is auto-generated from name using makeSlug helper
	_, err := h.queries.CreateProduct(ctx, sqlc.CreateProductParams{
		Sku:             c.FormValue("sku"),
		Slug:            makeSlug(c.FormValue("name")), // Generate URL-friendly slug from name
		Name:            c.FormValue("name"),
		Tagline:         sql.NullString{String: tagline, Valid: tagline != ""},         // Only store if not empty
		Description:     c.FormValue("description"),
		Overview:        sql.NullString{String: overview, Valid: overview != ""},       // Only store if not empty
		CategoryID:      categoryID,
		Status:          status,
		IsFeatured:      isFeatured,
		FeaturedOrder:   sql.NullInt64{Int64: featuredOrder, Valid: featuredOrder > 0}, // Only store if > 0
		MetaTitle:       sql.NullString{String: metaTitle, Valid: metaTitle != ""},     // Only store if not empty
		MetaDescription: sql.NullString{String: metaDesc, Valid: metaDesc != ""},       // Only store if not empty
		PrimaryImage:    imagePath,
		VideoUrl:        sql.NullString{String: videoURL, Valid: videoURL != ""},       // Only store if not empty
		PublishedAt:     publishedAt,
	})
	if err != nil {
		h.logger.Error("failed to create product", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Invalidate cached product list pages in the frontend
	h.cache.DeleteByPrefix("page:products")

	// Log this action to the admin activity log for audit trail
	logActivity(c, "created", "product", 0, c.FormValue("name"), "Created Product '%s'", c.FormValue("name"))

	// Redirect back to product list page after successful creation
	return c.Redirect(http.StatusSeeOther, "/admin/products")
}

// Edit handles GET requests to /admin/products/:id/edit
// Renders the product edit form pre-populated with existing product data.
//
// URL Parameters:
//   - id: Product ID to edit
//
// Template: admin/pages/products_form.html (full page render)
// HTMX: This endpoint returns a full HTML page, not a fragment
//
// Returns HTTP 404 if product ID is not found.
// The form is identical to the New form but pre-filled with existing values.
func (h *ProductsHandler) Edit(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch the existing product to edit
	product, err := h.queries.GetProduct(ctx, id)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound, "Product not found")
	}

	// Fetch all categories for the dropdown
	categories, err := h.queries.ListProductCategories(ctx)
	if err != nil {
		h.logger.Error("failed to list categories", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Fetch category slug to build preview URL for the frontend page
	var categorySlug string
	category, err := h.queries.GetProductCategory(ctx, product.CategoryID)
	if err == nil {
		categorySlug = category.Slug
	}

	// Render the form with existing product data
	return c.Render(http.StatusOK, "admin/pages/products_form.html", map[string]interface{}{
		"Title":        "Edit Product",
		"FormAction":   fmt.Sprintf("/admin/products/%d", id), // POST to this URL for update
		"Item":         product,                               // Pre-fill form with existing data
		"Categories":   categories,
		"CategorySlug": categorySlug,                          // For "Preview" button link
	})
}

// Update handles POST requests to /admin/products/:id
// Processes the product update form submission and updates the existing product in the database.
//
// URL Parameters:
//   - id: Product ID to update
//
// Form Fields: Same as Create handler (see Create documentation)
//
// On Success: Redirects to /admin/products (HTTP 303 See Other)
// On Error: Returns HTTP error with appropriate status code
//
// Special Handling:
//   - Only updates primary_image if a new file is uploaded (otherwise keeps existing)
//   - Only sets published_at if status changes from draft to published (preserves original date)
//
// Side Effects:
//   - Uploads new image to disk/storage if provided
//   - Invalidates product page cache
//   - Logs activity to audit trail
func (h *ProductsHandler) Update(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch existing product to preserve certain fields
	existing, err := h.queries.GetProduct(ctx, id)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound, "Product not found")
	}

	// Parse form values (same as Create)
	categoryID, _ := strconv.ParseInt(c.FormValue("category_id"), 10, 64)
	isFeatured := c.FormValue("is_featured") == "1"
	featuredOrder, _ := strconv.ParseInt(c.FormValue("featured_order"), 10, 64)

	tagline := c.FormValue("tagline")
	overview := c.FormValue("overview")
	metaTitle := c.FormValue("meta_title")
	metaDesc := c.FormValue("meta_description")
	videoURL := c.FormValue("video_url")

	// Keep existing image unless a new one is uploaded
	imagePath := existing.PrimaryImage
	if fileHeader, err := c.FormFile("primary_image"); err == nil {
		// New image provided, upload and replace
		path, err := h.uploadSvc.UploadProductImage(fileHeader)
		if err != nil {
			h.logger.Error("failed to upload image", "error", err)
			return echo.NewHTTPError(http.StatusBadRequest, "Failed to upload image")
		}
		imagePath = sql.NullString{String: path, Valid: true}
	}

	// Only set published_at if transitioning from draft to published
	// This preserves the original publish date for already-published products
	status := c.FormValue("status")
	publishedAt := existing.PublishedAt
	if status == "published" && !existing.PublishedAt.Valid {
		publishedAt = sql.NullTime{Time: time.Now(), Valid: true}
	}

	// Update the product record with new values
	err = h.queries.UpdateProduct(ctx, sqlc.UpdateProductParams{
		Sku:             c.FormValue("sku"),
		Slug:            makeSlug(c.FormValue("name")), // Regenerate slug in case name changed
		Name:            c.FormValue("name"),
		Tagline:         sql.NullString{String: tagline, Valid: tagline != ""},
		Description:     c.FormValue("description"),
		Overview:        sql.NullString{String: overview, Valid: overview != ""},
		CategoryID:      categoryID,
		Status:          status,
		IsFeatured:      isFeatured,
		FeaturedOrder:   sql.NullInt64{Int64: featuredOrder, Valid: featuredOrder > 0},
		MetaTitle:       sql.NullString{String: metaTitle, Valid: metaTitle != ""},
		MetaDescription: sql.NullString{String: metaDesc, Valid: metaDesc != ""},
		PrimaryImage:    imagePath,    // Either new image or existing
		VideoUrl:        sql.NullString{String: videoURL, Valid: videoURL != ""},
		PublishedAt:     publishedAt,  // Either new timestamp or preserved original
		ID:              id,
	})
	if err != nil {
		h.logger.Error("failed to update product", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Invalidate frontend product page cache
	h.cache.DeleteByPrefix("page:products")

	// Log update to audit trail
	logActivity(c, "updated", "product", id, c.FormValue("name"), "Updated Product '%s'", c.FormValue("name"))

	// Redirect back to product list
	return c.Redirect(http.StatusSeeOther, "/admin/products")
}

// Delete handles DELETE requests to /admin/products/:id
// Permanently deletes a product from the database.
//
// URL Parameters:
//   - id: Product ID to delete
//
// HTMX: This endpoint returns an empty response (HTTP 204 No Content)
// The frontend HTMX handles removing the row from the table on success.
//
// Note: This performs a hard delete. Related product_specs, product_features,
// product_certifications, product_downloads, and product_images should be
// cascade deleted via database foreign key constraints.
//
// Side Effects:
//   - Invalidates product page cache
//   - Logs deletion to audit trail
func (h *ProductsHandler) Delete(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Delete the product from database
	if err := h.queries.DeleteProduct(c.Request().Context(), id); err != nil {
		h.logger.Error("failed to delete product", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Invalidate frontend cache
	h.cache.DeleteByPrefix("page:products")

	// Log deletion to audit trail
	logActivity(c, "deleted", "product", id, "", "Deleted Product #%d", id)

	// Return empty 204 response (HTMX will remove the row)
	return c.NoContent(http.StatusOK)
}
