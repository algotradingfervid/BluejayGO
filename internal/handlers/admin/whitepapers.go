// Package admin provides HTTP handlers for the admin panel content management features.
// This file contains handlers for managing Whitepapers â€” downloadable PDF resources for lead generation.
package admin

import (
	// Standard library imports
	"database/sql" // Used for nullable SQL types (NullString, NullInt64)
	"fmt"          // String formatting for generating unique filenames
	"io"           // File copying operations for PDF uploads
	"log/slog"     // Structured logging for error tracking and debugging
	"math"         // Used for math.Ceil to calculate total pages from item count
	"net/http"     // HTTP status codes for responses
	"os"           // File system operations (Create, MkdirAll, Remove)
	"path/filepath" // Path manipulation for upload directory handling
	"strconv"      // String to integer conversions for route params and form values
	"time"         // Unix timestamp for unique filename generation

	// Third-party imports
	"github.com/labstack/echo/v4" // Echo web framework for HTTP routing and context handling

	// Internal imports
	"github.com/narendhupati/bluejay-cms/db/sqlc"           // Generated SQL queries from sqlc
	"github.com/narendhupati/bluejay-cms/internal/services" // Service layer including cache implementation
)

// WhitepapersHandler handles all HTTP requests for whitepapers management in the admin panel.
// It manages CRUD operations for whitepapers, PDF file uploads, and download tracking.
type WhitepapersHandler struct {
	queries *sqlc.Queries   // Database query interface generated by sqlc
	logger  *slog.Logger    // Structured logger for error tracking
	cache   *services.Cache // Cache service for invalidating page cache after updates
}

// NewWhitepapersHandler creates and initializes a new WhitepapersHandler with required dependencies.
// Parameters:
//   - queries: sqlc-generated database query interface
//   - logger: structured logger for error logging
//   - cache: cache service for cache invalidation
//
// Returns a fully initialized WhitepapersHandler ready to handle HTTP requests.
func NewWhitepapersHandler(queries *sqlc.Queries, logger *slog.Logger, cache *services.Cache) *WhitepapersHandler {
	return &WhitepapersHandler{
		queries: queries,
		logger:  logger,
		cache:   cache,
	}
}

// whitepapersPerPage defines the number of whitepapers to display per page in the list view.
const whitepapersPerPage = 15

// List displays all whitepapers with filtering and pagination.
//
// HTTP Method: GET
// Route: /admin/whitepapers
// Template: admin/pages/whitepapers_list.html (full page render)
// HTMX: No - returns full page
//
// Query Parameters:
//   - search: Filter whitepapers by title or description (text search)
//   - status: Filter by publication status ("published", "draft", or empty for all)
//   - topic: Filter by topic ID (int64)
//   - page: Current page number (default: 1)
//
// This handler retrieves a paginated list of whitepapers, applies filters, loads
// topics for the filter dropdown, and renders the whitepapers list page.
func (h *WhitepapersHandler) List(c echo.Context) error {
	ctx := c.Request().Context()

	search := c.QueryParam("search")
	status := c.QueryParam("status")
	topicStr := c.QueryParam("topic")
	pageStr := c.QueryParam("page")

	var topicID int64
	if topicStr != "" {
		topicID, _ = strconv.ParseInt(topicStr, 10, 64)
	}

	page, _ := strconv.Atoi(pageStr)
	if page < 1 {
		page = 1
	}
	offset := int64((page - 1) * whitepapersPerPage)

	filterParams := sqlc.ListWhitepapersAdminFilteredParams{
		FilterSearch: search,
		FilterTopic:  topicID,
		FilterStatus: status,
		PageLimit:    whitepapersPerPage,
		PageOffset:   offset,
	}

	whitepapers, err := h.queries.ListWhitepapersAdminFiltered(ctx, filterParams)
	if err != nil {
		h.logger.Error("Failed to list whitepapers", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load whitepapers")
	}

	total, err := h.queries.CountWhitepapersAdminFiltered(ctx, sqlc.CountWhitepapersAdminFilteredParams{
		FilterSearch: search,
		FilterTopic:  topicID,
		FilterStatus: status,
	})
	if err != nil {
		h.logger.Error("Failed to count whitepapers", "error", err)
		total = 0
	}

	topics, err := h.queries.ListWhitepaperTopics(ctx)
	if err != nil {
		h.logger.Error("Failed to list whitepaper topics", "error", err)
	}

	totalPages := int(math.Ceil(float64(total) / float64(whitepapersPerPage)))
	if totalPages < 1 {
		totalPages = 1
	}

	var pages []int
	for i := 1; i <= totalPages; i++ {
		pages = append(pages, i)
	}

	showFrom := offset + 1
	showTo := offset + int64(len(whitepapers))
	if total == 0 {
		showFrom = 0
	}

	hasFilters := search != "" || status != "" || topicStr != ""

	return c.Render(http.StatusOK, "admin/pages/whitepapers_list.html", map[string]interface{}{
		"Title":       "Whitepapers",
		"Whitepapers": whitepapers,
		"Topics":      topics,
		"Search":      search,
		"Status":      status,
		"TopicID":     topicID,
		"HasFilters":  hasFilters,
		"Page":        page,
		"TotalPages":  totalPages,
		"Pages":       pages,
		"Total":       total,
		"ShowFrom":    showFrom,
		"ShowTo":      showTo,
	})
}

// New displays the form for creating a new whitepaper.
//
// HTTP Method: GET
// Route: /admin/whitepapers/new
// Template: admin/pages/whitepapers_form.html (full page render)
// HTMX: No - returns full page
//
// This handler renders an empty whitepaper creation form and loads the topics
// list for the topic dropdown selector. The form submits to the Create handler
// via POST /admin/whitepapers with multipart/form-data encoding for PDF upload.
func (h *WhitepapersHandler) New(c echo.Context) error {
	topics, err := h.queries.ListWhitepaperTopics(c.Request().Context())
	if err != nil {
		h.logger.Error("Failed to list whitepaper topics", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load topics")
	}

	return c.Render(http.StatusOK, "admin/pages/whitepapers_form.html", map[string]interface{}{
		"Title":      "New Whitepaper",
		"FormAction": "/admin/whitepapers",
		"Item":       nil,
		"Topics":     topics,
		"IsNew":      true,
	})
}

// Create handles whitepaper creation.
//
// HTTP Method: POST
// Route: /admin/whitepapers
// HTMX: No - performs redirect after success
// Template: None - redirects to /admin/whitepapers on success
//
// Form Fields:
//   - title: Whitepaper title (required)
//   - slug: URL slug (auto-generated from title if empty)
//   - description: Brief description of the whitepaper content
//   - topic_id: Topic category ID (foreign key to whitepaper_topics table)
//   - published_date: Publication date (date string)
//   - cover_color_from: Gradient start color for cover design
//   - cover_color_to: Gradient end color for cover design
//   - meta_description: SEO meta description
//   - is_published: Publication status ("on" or empty)
//   - page_count: Number of pages in the PDF (integer, optional)
//   - pdf_file: Uploaded PDF file (multipart file upload)
//   - learning_points[]: Array of learning point text items
//
// Business Logic:
//   - Handles multipart form data with 50MB max size
//   - Uploads PDF file to public/uploads/whitepapers/ directory
//   - Generates unique filename using Unix timestamp and slugified title
//   - Stores file size in bytes for display purposes
//   - Creates learning points as separate related records
//   - Invalidates "page:whitepapers" cache entries after creation
func (h *WhitepapersHandler) Create(c echo.Context) error {
	if err := c.Request().ParseMultipartForm(50 << 20); err != nil {
		h.logger.Error("Failed to parse multipart form", "error", err)
		return c.String(http.StatusBadRequest, "Failed to parse form")
	}

	title := c.FormValue("title")
	slug := c.FormValue("slug")
	if slug == "" {
		slug = makeSlug(title)
	}

	description := c.FormValue("description")
	publishedDate := c.FormValue("published_date")
	coverColorFrom := c.FormValue("cover_color_from")
	coverColorTo := c.FormValue("cover_color_to")
	metaDescription := c.FormValue("meta_description")

	topicID := int64(0)
	if v := c.FormValue("topic_id"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			topicID = parsed
		}
	}

	isPublished := int64(0)
	if c.FormValue("is_published") == "on" {
		isPublished = 1
	}

	pageCount := sql.NullInt64{}
	if v := c.FormValue("page_count"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			pageCount = sql.NullInt64{Int64: parsed, Valid: true}
		}
	}

	// Handle optional PDF file upload from multipart form
	pdfFilePath := ""
	var fileSizeBytes int64
	file, err := c.FormFile("pdf_file")
	if err == nil && file != nil {
		// Open the uploaded file for reading
		src, err := file.Open()
		if err != nil {
			h.logger.Error("Failed to open uploaded file", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to process upload")
		}
		defer src.Close()

		// Ensure upload directory exists (create if needed)
		uploadDir := "public/uploads/whitepapers"
		if err := os.MkdirAll(uploadDir, 0755); err != nil {
			h.logger.Error("Failed to create upload directory", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to create upload directory")
		}

		// Generate unique filename: timestamp_slug.pdf
		ext := filepath.Ext(file.Filename)
		filename := fmt.Sprintf("%d_%s%s", time.Now().UnixNano(), makeSlug(title), ext)
		dstPath := filepath.Join(uploadDir, filename)

		// Create destination file
		dst, err := os.Create(dstPath)
		if err != nil {
			h.logger.Error("Failed to create destination file", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to save file")
		}
		defer dst.Close()

		// Copy uploaded file to destination and track bytes written
		written, err := io.Copy(dst, src)
		if err != nil {
			h.logger.Error("Failed to copy file", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to save file")
		}

		// Store web-accessible path (without "public" prefix)
		pdfFilePath = "/uploads/whitepapers/" + filename
		fileSizeBytes = written
	}

	params := sqlc.CreateWhitepaperParams{
		Title:           title,
		Slug:            slug,
		Description:     description,
		TopicID:         topicID,
		PdfFilePath:     pdfFilePath,
		FileSizeBytes:   fileSizeBytes,
		PageCount:       pageCount,
		PublishedDate:   publishedDate,
		IsPublished:     isPublished,
		CoverColorFrom:  coverColorFrom,
		CoverColorTo:    coverColorTo,
		MetaDescription: sql.NullString{String: metaDescription, Valid: metaDescription != ""},
	}

	whitepaper, err := h.queries.CreateWhitepaper(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to create whitepaper", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to create whitepaper")
	}

	// Handle learning points array from form (e.g., <input name="learning_points[]">)
	// Creates separate database records for each learning point
	learningPoints := c.Request().Form["learning_points[]"]
	for i, point := range learningPoints {
		if point == "" {
			continue // Skip empty entries
		}
		_, err := h.queries.CreateWhitepaperLearningPoint(c.Request().Context(), sqlc.CreateWhitepaperLearningPointParams{
			WhitepaperID: whitepaper.ID,
			PointText:    point,
			DisplayOrder: int64(i + 1), // 1-indexed display order
		})
		if err != nil {
			h.logger.Error("Failed to create learning point", "error", err)
			// Continue processing other points even if one fails
		}
	}

	h.cache.DeleteByPrefix("page:whitepapers")
	logActivity(c, "created", "whitepaper", 0, c.FormValue("title"), "Created Whitepaper '%s'", c.FormValue("title"))
	return c.Redirect(http.StatusSeeOther, "/admin/whitepapers")
}

// Edit displays the form for editing a whitepaper.
//
// HTTP Method: GET
// Route: /admin/whitepapers/:id/edit
// Template: admin/pages/whitepapers_form.html (full page render)
// HTMX: No - returns full page
//
// Route Parameters:
//   - id: Whitepaper ID (int64)
//
// This handler loads an existing whitepaper and its related data:
//   - Whitepaper basic data
//   - Topics list for dropdown
//   - Learning points (key takeaways from the whitepaper)
//
// The form submits to the Update handler via POST /admin/whitepapers/:id.
func (h *WhitepapersHandler) Edit(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid whitepaper ID")
	}

	whitepaper, err := h.queries.GetWhitepaperByID(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get whitepaper", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load whitepaper")
	}

	topics, err := h.queries.ListWhitepaperTopics(c.Request().Context())
	if err != nil {
		h.logger.Error("Failed to list whitepaper topics", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load topics")
	}

	learningPoints, err := h.queries.GetWhitepaperLearningPoints(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get learning points", "error", err)
	}

	return c.Render(http.StatusOK, "admin/pages/whitepapers_form.html", map[string]interface{}{
		"Title":          "Edit Whitepaper",
		"FormAction":     "/admin/whitepapers/" + c.Param("id"),
		"Item":           whitepaper,
		"Topics":         topics,
		"LearningPoints": learningPoints,
		"IsNew":          false,
	})
}

// Update handles whitepaper updates.
//
// HTTP Method: POST
// Route: /admin/whitepapers/:id
// HTMX: No - performs redirect after success
// Template: None - redirects to /admin/whitepapers on success
//
// Route Parameters:
//   - id: Whitepaper ID (int64)
//
// Form Fields: Same as Create handler (see Create documentation)
//
// Business Logic:
//   - Updates whitepaper base record
//   - If new PDF uploaded, removes old file and stores new one
//   - Otherwise retains existing PDF file path and size
//   - Replaces all learning points (delete old, insert new)
//   - Invalidates "page:whitepapers" cache entries
func (h *WhitepapersHandler) Update(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid whitepaper ID")
	}

	if err := c.Request().ParseMultipartForm(50 << 20); err != nil {
		h.logger.Error("Failed to parse multipart form", "error", err)
		return c.String(http.StatusBadRequest, "Failed to parse form")
	}

	title := c.FormValue("title")
	slug := c.FormValue("slug")
	if slug == "" {
		slug = makeSlug(title)
	}

	description := c.FormValue("description")
	publishedDate := c.FormValue("published_date")
	coverColorFrom := c.FormValue("cover_color_from")
	coverColorTo := c.FormValue("cover_color_to")
	metaDescription := c.FormValue("meta_description")

	topicID := int64(0)
	if v := c.FormValue("topic_id"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			topicID = parsed
		}
	}

	isPublished := int64(0)
	if c.FormValue("is_published") == "on" {
		isPublished = 1
	}

	pageCount := sql.NullInt64{}
	if v := c.FormValue("page_count"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			pageCount = sql.NullInt64{Int64: parsed, Valid: true}
		}
	}

	// Get existing whitepaper for current PDF path
	existing, err := h.queries.GetWhitepaperByID(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get existing whitepaper", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load whitepaper")
	}

	pdfFilePath := existing.PdfFilePath
	fileSizeBytes := existing.FileSizeBytes

	// Handle optional PDF replacement
	file, err := c.FormFile("pdf_file")
	if err == nil && file != nil {
		src, err := file.Open()
		if err != nil {
			h.logger.Error("Failed to open uploaded file", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to process upload")
		}
		defer src.Close()

		uploadDir := "public/uploads/whitepapers"
		if err := os.MkdirAll(uploadDir, 0755); err != nil {
			h.logger.Error("Failed to create upload directory", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to create upload directory")
		}

		// Remove old file if it exists
		if existing.PdfFilePath != "" {
			oldPath := filepath.Join("public", existing.PdfFilePath)
			os.Remove(oldPath)
		}

		ext := filepath.Ext(file.Filename)
		filename := fmt.Sprintf("%d_%s%s", time.Now().UnixNano(), makeSlug(title), ext)
		dstPath := filepath.Join(uploadDir, filename)

		dst, err := os.Create(dstPath)
		if err != nil {
			h.logger.Error("Failed to create destination file", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to save file")
		}
		defer dst.Close()

		written, err := io.Copy(dst, src)
		if err != nil {
			h.logger.Error("Failed to copy file", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to save file")
		}

		pdfFilePath = "/uploads/whitepapers/" + filename
		fileSizeBytes = written
	}

	params := sqlc.UpdateWhitepaperParams{
		Title:           title,
		Slug:            slug,
		Description:     description,
		TopicID:         topicID,
		PdfFilePath:     pdfFilePath,
		FileSizeBytes:   fileSizeBytes,
		PageCount:       pageCount,
		PublishedDate:   publishedDate,
		IsPublished:     isPublished,
		CoverColorFrom:  coverColorFrom,
		CoverColorTo:    coverColorTo,
		MetaDescription: sql.NullString{String: metaDescription, Valid: metaDescription != ""},
		ID:              id,
	}

	err = h.queries.UpdateWhitepaper(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to update whitepaper", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to update whitepaper")
	}

	// Replace learning points: delete all existing, then insert new ones
	// This ensures clean state and prevents orphaned records
	err = h.queries.DeleteWhitepaperLearningPoints(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to delete old learning points", "error", err)
	}

	// Insert new learning points from form array
	learningPoints := c.Request().Form["learning_points[]"]
	for i, point := range learningPoints {
		if point == "" {
			continue // Skip empty entries
		}
		_, err := h.queries.CreateWhitepaperLearningPoint(c.Request().Context(), sqlc.CreateWhitepaperLearningPointParams{
			WhitepaperID: id,
			PointText:    point,
			DisplayOrder: int64(i + 1), // 1-indexed display order
		})
		if err != nil {
			h.logger.Error("Failed to create learning point", "error", err)
			// Continue processing other points
		}
	}

	h.cache.DeleteByPrefix("page:whitepapers")
	logActivity(c, "updated", "whitepaper", id, c.FormValue("title"), "Updated Whitepaper '%s'", c.FormValue("title"))
	return c.Redirect(http.StatusSeeOther, "/admin/whitepapers")
}

// Delete handles whitepaper deletion.
//
// HTTP Method: DELETE
// Route: /admin/whitepapers/:id
// HTMX: Yes - triggered by hx-delete on delete button
// Template: None - returns HTTP 200 OK
//
// Route Parameters:
//   - id: Whitepaper ID (int64)
//
// Business Logic:
//   - Loads whitepaper to get PDF file path
//   - Deletes whitepaper record from database (cascade deletes learning points)
//   - Removes PDF file from filesystem
//   - Invalidates "page:whitepapers" cache entries
//   - Returns 200 OK (not 204) for HTMX compatibility
func (h *WhitepapersHandler) Delete(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid whitepaper ID")
	}

	// Get whitepaper to find PDF path for cleanup
	whitepaper, err := h.queries.GetWhitepaperByID(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get whitepaper for deletion", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load whitepaper")
	}

	err = h.queries.DeleteWhitepaper(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to delete whitepaper", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to delete whitepaper")
	}

	// Remove PDF file
	if whitepaper.PdfFilePath != "" {
		oldPath := filepath.Join("public", whitepaper.PdfFilePath)
		os.Remove(oldPath)
	}

	h.cache.DeleteByPrefix("page:whitepapers")
	logActivity(c, "deleted", "whitepaper", id, "", "Deleted Whitepaper #%d", id)
	return c.NoContent(http.StatusOK)
}

// Downloads lists all whitepaper download leads with filtering and pagination.
//
// HTTP Method: GET
// Route: /admin/whitepapers/downloads
// Template: admin/pages/whitepapers_downloads.html (full page render)
// HTMX: No - returns full page
//
// Query Parameters:
//   - whitepaper: Filter by whitepaper ID (int64)
//   - date_from: Filter downloads from this date (date string)
//   - date_to: Filter downloads up to this date (date string)
//   - page: Current page number (default: 1)
//
// Business Logic:
//   - Shows all leads who downloaded whitepapers (for lead generation tracking)
//   - Each download record includes user email, name, company, and timestamp
//   - Uses 25 items per page (different from whitepaper list view)
//   - Loads all whitepapers for filter dropdown
//
// This handler is used for lead generation analytics and follow-up.
func (h *WhitepapersHandler) Downloads(c echo.Context) error {
	ctx := c.Request().Context()

	whitepaperStr := c.QueryParam("whitepaper")
	dateFrom := c.QueryParam("date_from")
	dateTo := c.QueryParam("date_to")
	pageStr := c.QueryParam("page")

	var whitepaperID int64
	if whitepaperStr != "" {
		whitepaperID, _ = strconv.ParseInt(whitepaperStr, 10, 64)
	}

	page, _ := strconv.Atoi(pageStr)
	if page < 1 {
		page = 1
	}

	perPage := int64(25)
	offset := int64((page - 1)) * perPage

	downloads, err := h.queries.ListWhitepaperDownloadsFiltered(ctx, sqlc.ListWhitepaperDownloadsFilteredParams{
		FilterWhitepaper: whitepaperID,
		FilterDateFrom:   dateFrom,
		FilterDateTo:     dateTo,
		PageLimit:        perPage,
		PageOffset:       offset,
	})
	if err != nil {
		h.logger.Error("Failed to list whitepaper downloads", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load downloads")
	}

	totalCount, err := h.queries.CountWhitepaperDownloadsFiltered(ctx, sqlc.CountWhitepaperDownloadsFilteredParams{
		FilterWhitepaper: whitepaperID,
		FilterDateFrom:   dateFrom,
		FilterDateTo:     dateTo,
	})
	if err != nil {
		h.logger.Error("Failed to count whitepaper downloads", "error", err)
		totalCount = 0
	}

	totalPages := int(math.Ceil(float64(totalCount) / float64(perPage)))
	if totalPages < 1 {
		totalPages = 1
	}

	var pages []int
	for i := 1; i <= totalPages; i++ {
		pages = append(pages, i)
	}

	// Get whitepapers list for filter dropdown
	whitepapers, err := h.queries.ListAllWhitepapers(ctx)
	if err != nil {
		h.logger.Error("Failed to list whitepapers for filter", "error", err)
	}

	hasFilters := whitepaperStr != "" || dateFrom != "" || dateTo != ""

	return c.Render(http.StatusOK, "admin/pages/whitepapers_downloads.html", map[string]interface{}{
		"Title":        "Whitepaper Downloads",
		"Downloads":    downloads,
		"Whitepapers":  whitepapers,
		"WhitepaperID": whitepaperID,
		"DateFrom":     dateFrom,
		"DateTo":       dateTo,
		"HasFilters":   hasFilters,
		"Page":         page,
		"TotalPages":   totalPages,
		"Pages":        pages,
		"TotalCount":   totalCount,
	})
}
