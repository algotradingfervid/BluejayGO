package admin

import (
	// Standard library imports for data handling and HTTP operations
	"log/slog"  // Structured logging for error tracking
	"net/http"  // HTTP status codes and error responses
	"strconv"   // String to integer conversions for tag IDs
	"strings"   // String manipulation for trimming search queries

	// Third-party framework imports
	"github.com/labstack/echo/v4" // Echo web framework for routing and context handling

	// Internal application imports
	"github.com/narendhupati/bluejay-cms/db/sqlc" // Generated SQL queries via sqlc
)

// BlogTagsHandler manages all HTTP handlers for blog tag CRUD operations.
// Tags are simpler than categories - they only have name and slug fields.
// Tags support HTMX-powered search/autocomplete and quick-create functionality.
type BlogTagsHandler struct {
	queries *sqlc.Queries // Database query interface generated by sqlc
	logger  *slog.Logger  // Structured logger for error tracking
}

// NewBlogTagsHandler constructs a new BlogTagsHandler with required dependencies.
func NewBlogTagsHandler(queries *sqlc.Queries, logger *slog.Logger) *BlogTagsHandler {
	return &BlogTagsHandler{queries: queries, logger: logger}
}

// List handles GET /admin/blog/tags
// Renders the complete list of all blog tags without pagination.
// Template: admin/pages/blog_tags_list.html (full page)
// Tags are typically displayed alphabetically by name.
func (h *BlogTagsHandler) List(c echo.Context) error {
	// Fetch all blog tags from the database
	tags, err := h.queries.ListAllBlogTags(c.Request().Context())
	if err != nil {
		h.logger.Error("failed to list blog tags", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Render the full list page
	return c.Render(http.StatusOK, "admin/pages/blog_tags_list.html", map[string]interface{}{
		"Title": "Blog Tags",
		"Items": tags,
	})
}

// Create handles POST /admin/blog/tags
// Processes the blog tag creation form submission from the main list page.
// Auto-generates slug from name. Redirects back to /admin/blog/tags on success.
// Note: This is for the traditional form-based creation. See QuickCreate for HTMX inline creation.
func (h *BlogTagsHandler) Create(c echo.Context) error {
	name := c.FormValue("name")

	// Insert the blog tag into the database
	// Slug is auto-generated from name using makeSlug utility function
	_, err := h.queries.CreateBlogTag(c.Request().Context(), sqlc.CreateBlogTagParams{
		Name: name,
		Slug: makeSlug(name), // Auto-generate URL-friendly slug
	})
	if err != nil {
		h.logger.Error("failed to create blog tag", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the creation activity for audit trail
	logActivity(c, "created", "blog_tag", 0, name, "Created blog_tag '%s'", name)
	return c.Redirect(http.StatusSeeOther, "/admin/blog/tags")
}

// Search handles GET /admin/blog/tags/search?_tag_search=query
// Returns an HTML fragment with tag suggestions for HTMX-powered autocomplete.
// HTMX behavior: Returns HTML partial, not full page. Target: tag suggestions container.
// Template: admin/partials/tag_suggestions.html (HTML fragment)
// Used in blog post form to search and select existing tags before adding them to a post.
func (h *BlogTagsHandler) Search(c echo.Context) error {
	query := strings.TrimSpace(c.QueryParam("_tag_search"))

	// Return empty suggestions if query is blank
	if query == "" {
		return c.Render(http.StatusOK, "admin/partials/tag_suggestions.html", map[string]interface{}{
			"Tags":  nil,
			"Query": "",
		})
	}

	// Search for tags matching the query (LIKE search with wildcards)
	tags, _ := h.queries.SearchBlogTags(c.Request().Context(), "%"+query+"%")

	// Render tag suggestions as HTML fragment for HTMX to inject into DOM
	return c.Render(http.StatusOK, "admin/partials/tag_suggestions.html", map[string]interface{}{
		"Tags":  tags,
		"Query": query,
	})
}

// QuickCreate handles POST /admin/blog/tags/quick-create
// Creates a new tag and returns it as an HTML chip for immediate inline addition.
// HTMX behavior: Returns HTML partial (tag chip), not full page. Target: selected tags container.
// Template: admin/partials/tag_chip.html (HTML fragment)
// Used in blog post form when user creates a new tag on-the-fly without leaving the form.
// This enables a seamless UX where users can create and select tags without page navigation.
func (h *BlogTagsHandler) QuickCreate(c echo.Context) error {
	name := strings.TrimSpace(c.FormValue("name"))

	// Validate that tag name is not empty
	if name == "" {
		return c.NoContent(http.StatusBadRequest)
	}

	// Insert the new tag into the database
	tag, err := h.queries.CreateBlogTag(c.Request().Context(), sqlc.CreateBlogTagParams{
		Name: name,
		Slug: makeSlug(name), // Auto-generate slug from name
	})
	if err != nil {
		h.logger.Error("failed to quick-create blog tag", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the creation activity for audit trail
	logActivity(c, "created", "blog_tag", 0, name, "Created blog_tag '%s'", name)

	// Render the tag as an HTML chip that gets inserted into the selected tags area
	// HTMX will swap this response into the DOM, visually adding the tag to the post
	return c.Render(http.StatusOK, "admin/partials/tag_chip.html", map[string]interface{}{
		"ID":   tag.ID,
		"Name": tag.Name,
	})
}

// Delete handles DELETE /admin/blog/tags/:id
// Deletes a blog tag from the database and all its post associations.
// HTMX behavior: Returns 200 OK with no content, triggering client-side row removal.
// Note: Deleting a tag also removes it from all blog posts (cascade delete on junction table).
func (h *BlogTagsHandler) Delete(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Attempt to delete the tag
	// Junction table entries (blog_post_tags) are automatically deleted via cascade
	if err := h.queries.DeleteBlogTag(c.Request().Context(), id); err != nil {
		h.logger.Error("failed to delete blog tag", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the deletion activity for audit trail
	logActivity(c, "deleted", "blog_tag", id, "", "Deleted blog_tag #%d", id)

	// Return empty 200 OK response for HTMX to process
	return c.NoContent(http.StatusOK)
}
