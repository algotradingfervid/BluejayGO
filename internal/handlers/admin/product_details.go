// Package admin provides HTTP handlers for the admin panel product management functionality.
// This file contains handlers for managing product details including specifications, features,
// certifications, downloadable files, and image galleries. All handlers in this file return
// HTML fragments for HTMX swap operations rather than full pages.
package admin

import (
	"database/sql"       // Used for nullable database types (sql.NullString, sql.NullInt64)
	"fmt"                // Used for error formatting and string operations
	"html/template"      // Used for rendering partial HTML templates
	"log/slog"           // Structured logging for error messages
	"net/http"           // HTTP status codes and content type headers
	"path/filepath"      // Used for constructing template file paths
	"strconv"            // String to integer conversion for URL params and form values

	"github.com/labstack/echo/v4"                      // Echo web framework for routing and context
	"github.com/narendhupati/bluejay-cms/db/sqlc"      // sqlc-generated database queries
	"github.com/narendhupati/bluejay-cms/internal/services" // Upload service for file and image handling
)

// ProductDetailsHandler handles HTTP requests for managing product details and related entities.
// This includes specs, features, certifications, downloads, and images. All handlers return
// HTML fragments suitable for HTMX swapping rather than full page renders.
type ProductDetailsHandler struct {
	queries   *sqlc.Queries                     // Database queries generated by sqlc
	logger    *slog.Logger                      // Structured logger for error reporting
	uploadSvc *services.UploadService           // Service for handling file and image uploads
	partials  map[string]*template.Template     // Pre-parsed partial templates for performance
}

// NewProductDetailsHandler creates and returns a new ProductDetailsHandler instance.
// It pre-loads all partial templates during initialization for better performance.
// This constructor is typically called during application initialization.
func NewProductDetailsHandler(queries *sqlc.Queries, logger *slog.Logger, uploadSvc *services.UploadService) *ProductDetailsHandler {
	h := &ProductDetailsHandler{
		queries:   queries,
		logger:    logger,
		uploadSvc: uploadSvc,
		partials:  make(map[string]*template.Template),
	}
	// Pre-parse all partial templates at initialization
	h.loadPartials()
	return h
}

// loadPartials pre-parses and caches all partial templates used by this handler.
// This is called once during initialization to avoid re-parsing templates on every request.
// All partials are stored in templates/admin/partials/ directory.
func (h *ProductDetailsHandler) loadPartials() {
	basePath := "templates"
	// List of partial template names (without .html extension)
	names := []string{
		"product_specs",          // Specification table partial
		"product_features",       // Features list partial
		"product_certifications", // Certifications grid partial
		"product_downloads",      // Downloads table partial
		"product_images",         // Image gallery partial
	}
	// Parse each partial template and store in map
	for _, name := range names {
		h.partials[name] = template.Must(template.ParseFiles(
			filepath.Join(basePath, "admin/partials", name+".html"),
		))
	}
}

// renderPartial renders a pre-parsed partial template with the provided data.
// This is used by all detail handlers to return HTML fragments for HTMX swaps.
//
// HTMX Behavior: All handlers using this method return HTML fragments that replace
// the target element's innerHTML (typically using hx-swap="innerHTML").
func (h *ProductDetailsHandler) renderPartial(c echo.Context, name string, data interface{}) error {
	// Lookup the pre-parsed template
	tmpl, ok := h.partials[name]
	if !ok {
		return fmt.Errorf("partial not found: %s", name)
	}
	// Set content type header for HTML
	c.Response().Header().Set(echo.HeaderContentType, echo.MIMETextHTMLCharsetUTF8)
	c.Response().WriteHeader(http.StatusOK)
	// Execute the template and write to response
	return tmpl.ExecuteTemplate(c.Response(), name, data)
}

// --- Product Specifications Section ---
// Specs are key-value pairs organized by section (e.g., "Dimensions", "Power", etc.)

// ListSpecs handles GET requests to /admin/products/:id/specs
// Returns the specifications table as an HTML fragment for HTMX swap.
//
// URL Parameters:
//   - id: Product ID
//
// Template: admin/partials/product_specs.html (partial fragment)
// HTMX: Returns HTML fragment that replaces the specs container
func (h *ProductDetailsHandler) ListSpecs(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch all specifications for this product
	specs, err := h.queries.ListProductSpecs(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("failed to list specs", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Render the specs partial template
	return h.renderPartial(c, "product_specs", map[string]interface{}{
		"ProductID": id,
		"Specs":     specs,
	})
}

// AddSpec handles POST requests to /admin/products/:id/specs
// Creates a new specification and returns the updated specs table.
//
// URL Parameters:
//   - id: Product ID
//
// Form Fields:
//   - section_name: Grouping name (e.g., "Dimensions", "Performance")
//   - spec_key: Specification label (e.g., "Weight", "Power")
//   - spec_value: Specification value (e.g., "5 kg", "120W")
//   - display_order: Sort order for display
//
// HTMX: Returns updated specs table fragment after successful creation
// The response triggers a swap that replaces the entire specs container
func (h *ProductDetailsHandler) AddSpec(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
	order, _ := strconv.ParseInt(c.FormValue("display_order"), 10, 64)

	// Insert the new specification
	_, err := h.queries.CreateProductSpec(ctx, sqlc.CreateProductSpecParams{
		ProductID:    id,
		SectionName:  c.FormValue("section_name"),
		SpecKey:      c.FormValue("spec_key"),
		SpecValue:    c.FormValue("spec_value"),
		DisplayOrder: order,
	})
	if err != nil {
		h.logger.Error("failed to create spec", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the activity for audit trail
	logActivity(c, "updated", "product", id, "", "Added spec to Product #%d", id)

	// Return the refreshed specs list
	return h.ListSpecs(c)
}

// DeleteSpecs handles DELETE requests to /admin/products/:id/specs
// Deletes ALL specifications for a product and returns the empty specs table.
//
// URL Parameters:
//   - id: Product ID
//
// HTMX: Returns empty/cleared specs table fragment after deletion
// This is a bulk delete operation that removes all specs for the product
func (h *ProductDetailsHandler) DeleteSpecs(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Delete all specs for this product
	if err := h.queries.DeleteProductSpecs(c.Request().Context(), id); err != nil {
		h.logger.Error("failed to delete specs", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the bulk deletion
	logActivity(c, "updated", "product", id, "", "Deleted specs from Product #%d", id)

	// Return the refreshed (now empty) specs list
	return h.ListSpecs(c)
}

// --- Product Features Section ---
// Features are bullet points highlighting product capabilities

// ListFeatures handles GET requests to /admin/products/:id/features
// Returns the features list as an HTML fragment for HTMX swap.
//
// URL Parameters:
//   - id: Product ID
//
// Template: admin/partials/product_features.html (partial fragment)
// HTMX: Returns HTML fragment that replaces the features container
func (h *ProductDetailsHandler) ListFeatures(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch all features for this product
	features, err := h.queries.ListProductFeatures(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("failed to list features", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Render the features partial template
	return h.renderPartial(c, "product_features", map[string]interface{}{
		"ProductID": id,
		"Features":  features,
	})
}

// AddFeature handles POST requests to /admin/products/:id/features
// Creates a new feature and returns the updated features list.
//
// URL Parameters:
//   - id: Product ID
//
// Form Fields:
//   - feature_text: The feature description/bullet point
//   - display_order: Sort order for display
//
// HTMX: Returns updated features list fragment after successful creation
func (h *ProductDetailsHandler) AddFeature(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
	order, _ := strconv.ParseInt(c.FormValue("display_order"), 10, 64)

	// Insert the new feature
	_, err := h.queries.CreateProductFeature(ctx, sqlc.CreateProductFeatureParams{
		ProductID:    id,
		FeatureText:  c.FormValue("feature_text"),
		DisplayOrder: order,
	})
	if err != nil {
		h.logger.Error("failed to create feature", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the activity for audit trail
	logActivity(c, "updated", "product", id, "", "Added feature to Product #%d", id)

	// Return the refreshed features list
	return h.ListFeatures(c)
}

// DeleteFeatures handles DELETE requests to /admin/products/:id/features
// Deletes ALL features for a product and returns the empty features list.
//
// URL Parameters:
//   - id: Product ID
//
// HTMX: Returns empty/cleared features list fragment after deletion
// This is a bulk delete operation that removes all features for the product
func (h *ProductDetailsHandler) DeleteFeatures(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Delete all features for this product
	if err := h.queries.DeleteProductFeatures(c.Request().Context(), id); err != nil {
		h.logger.Error("failed to delete features", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the bulk deletion
	logActivity(c, "updated", "product", id, "", "Deleted features from Product #%d", id)

	// Return the refreshed (now empty) features list
	return h.ListFeatures(c)
}

// --- Product Certifications Section ---
// Certifications display compliance badges (CE, UL, ISO, etc.)

// ListCertifications handles GET requests to /admin/products/:id/certifications
// Returns the certifications grid as an HTML fragment for HTMX swap.
//
// URL Parameters:
//   - id: Product ID
//
// Template: admin/partials/product_certifications.html (partial fragment)
// HTMX: Returns HTML fragment that replaces the certifications container
func (h *ProductDetailsHandler) ListCertifications(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch all certifications for this product
	certs, err := h.queries.ListProductCertifications(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("failed to list certifications", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Render the certifications partial template
	return h.renderPartial(c, "product_certifications", map[string]interface{}{
		"ProductID":      id,
		"Certifications": certs,
	})
}

// AddCertification handles POST requests to /admin/products/:id/certifications
// Creates a new certification and returns the updated certifications grid.
//
// URL Parameters:
//   - id: Product ID
//
// Form Fields:
//   - certification_name: Name of the certification (e.g., "CE Certified")
//   - certification_code: Optional certification number/code
//   - icon_type: Type of icon display (e.g., "image", "badge")
//   - icon_path: Path to certification icon/badge image
//   - display_order: Sort order for display
//
// HTMX: Returns updated certifications grid fragment after successful creation
func (h *ProductDetailsHandler) AddCertification(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
	order, _ := strconv.ParseInt(c.FormValue("display_order"), 10, 64)

	// Extract optional fields
	certCode := c.FormValue("certification_code")
	iconType := c.FormValue("icon_type")
	iconPath := c.FormValue("icon_path")

	// Insert the new certification with nullable optional fields
	_, err := h.queries.CreateProductCertification(ctx, sqlc.CreateProductCertificationParams{
		ProductID:         id,
		CertificationName: c.FormValue("certification_name"),
		CertificationCode: sql.NullString{String: certCode, Valid: certCode != ""}, // Only store if provided
		IconType:          sql.NullString{String: iconType, Valid: iconType != ""}, // Only store if provided
		IconPath:          sql.NullString{String: iconPath, Valid: iconPath != ""}, // Only store if provided
		DisplayOrder:      order,
	})
	if err != nil {
		h.logger.Error("failed to create certification", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the activity for audit trail
	logActivity(c, "updated", "product", id, "", "Added certification to Product #%d", id)

	// Return the refreshed certifications list
	return h.ListCertifications(c)
}

// DeleteCertifications handles DELETE requests to /admin/products/:id/certifications
// Deletes ALL certifications for a product and returns the empty certifications grid.
//
// URL Parameters:
//   - id: Product ID
//
// HTMX: Returns empty/cleared certifications grid fragment after deletion
// This is a bulk delete operation that removes all certifications for the product
func (h *ProductDetailsHandler) DeleteCertifications(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Delete all certifications for this product
	if err := h.queries.DeleteProductCertifications(c.Request().Context(), id); err != nil {
		h.logger.Error("failed to delete certifications", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the bulk deletion
	logActivity(c, "updated", "product", id, "", "Deleted certifications from Product #%d", id)

	// Return the refreshed (now empty) certifications list
	return h.ListCertifications(c)
}

// --- Product Downloads Section ---
// Downloads are files like manuals, datasheets, CAD models, etc.

// ListDownloads handles GET requests to /admin/products/:id/downloads
// Returns the downloads table as an HTML fragment for HTMX swap.
//
// URL Parameters:
//   - id: Product ID
//
// Template: admin/partials/product_downloads.html (partial fragment)
// HTMX: Returns HTML fragment that replaces the downloads container
func (h *ProductDetailsHandler) ListDownloads(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch all downloadable files for this product
	downloads, err := h.queries.ListProductDownloads(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("failed to list downloads", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Render the downloads partial template
	return h.renderPartial(c, "product_downloads", map[string]interface{}{
		"ProductID": id,
		"Downloads": downloads,
	})
}

// AddDownload handles POST requests to /admin/products/:id/downloads
// Uploads a file and creates a new download record, then returns the updated downloads table.
//
// URL Parameters:
//   - id: Product ID
//
// Form Fields:
//   - file: Required file upload (PDF, ZIP, etc.)
//   - title: Download title/label
//   - description: Optional description text
//   - file_type: Optional manual file type (auto-detected from extension if not provided)
//   - version: Optional version number
//   - display_order: Sort order for display
//
// HTMX: Returns updated downloads table fragment after successful upload
//
// Side Effects:
//   - Uploads file to disk/storage via UploadService
//   - Stores file metadata including size and type
func (h *ProductDetailsHandler) AddDownload(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
	order, _ := strconv.ParseInt(c.FormValue("display_order"), 10, 64)

	// File upload is required for downloads
	fileHeader, err := c.FormFile("file")
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "File is required")
	}

	// Upload the file using the upload service
	path, err := h.uploadSvc.UploadProductDownload(fileHeader)
	if err != nil {
		h.logger.Error("failed to upload download", "error", err)
		return echo.NewHTTPError(http.StatusBadRequest, "Failed to upload file: "+err.Error())
	}

	// Extract optional fields
	desc := c.FormValue("description")
	version := c.FormValue("version")
	fileType := c.FormValue("file_type")

	// Auto-detect file type from extension if not manually specified
	if fileType == "" {
		fileType = filepath.Ext(fileHeader.Filename)
	}

	// Create database record for the download
	_, err = h.queries.CreateProductDownload(ctx, sqlc.CreateProductDownloadParams{
		ProductID:    id,
		Title:        c.FormValue("title"),
		Description:  sql.NullString{String: desc, Valid: desc != ""},       // Only store if provided
		FileType:     fileType,
		FilePath:     path,                                                   // Stored path from upload service
		FileSize:     sql.NullInt64{Int64: fileHeader.Size, Valid: true},   // Store actual file size in bytes
		Version:      sql.NullString{String: version, Valid: version != ""}, // Only store if provided
		DisplayOrder: order,
	})
	if err != nil {
		h.logger.Error("failed to create download", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the activity for audit trail
	logActivity(c, "updated", "product", id, "", "Added download to Product #%d", id)

	// Return the refreshed downloads list
	return h.ListDownloads(c)
}

// DeleteDownload handles DELETE requests to /admin/products/:id/downloads/:download_id
// Deletes a single download and returns the updated downloads table.
//
// URL Parameters:
//   - id: Product ID
//   - download_id: Specific download ID to delete
//
// HTMX: Returns updated downloads table fragment after deletion
//
// Note: This deletes a single download, unlike specs/features/certifications
// which have bulk delete operations. Files may need manual cleanup from disk.
func (h *ProductDetailsHandler) DeleteDownload(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
	downloadID, _ := strconv.ParseInt(c.Param("download_id"), 10, 64)

	// Delete the specific download record
	if err := h.queries.DeleteProductDownload(c.Request().Context(), downloadID); err != nil {
		h.logger.Error("failed to delete download", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the deletion
	logActivity(c, "updated", "product", id, "", "Deleted download from Product #%d", id)

	// Return the refreshed downloads list
	return h.ListDownloads(c)
}

// --- Product Images Section ---
// Images are additional product photos for galleries, separate from primary_image

// ListImages handles GET requests to /admin/products/:id/images
// Returns the image gallery as an HTML fragment for HTMX swap.
//
// URL Parameters:
//   - id: Product ID
//
// Template: admin/partials/product_images.html (partial fragment)
// HTMX: Returns HTML fragment that replaces the images container
func (h *ProductDetailsHandler) ListImages(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch all gallery images for this product
	images, err := h.queries.ListProductImages(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("failed to list images", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Render the images partial template
	return h.renderPartial(c, "product_images", map[string]interface{}{
		"ProductID": id,
		"Images":    images,
	})
}

// AddImage handles POST requests to /admin/products/:id/images
// Uploads an image and creates a new gallery image record, then returns the updated gallery.
//
// URL Parameters:
//   - id: Product ID
//
// Form Fields:
//   - image: Required image file upload
//   - alt_text: Optional alt text for accessibility
//   - caption: Optional caption text
//   - is_thumbnail: Checkbox (value "1" if checked) - marks as thumbnail image
//   - display_order: Sort order for display
//
// HTMX: Returns updated image gallery fragment after successful upload
//
// Side Effects:
//   - Uploads image to disk/storage via UploadService
//   - May resize or optimize image depending on upload service configuration
func (h *ProductDetailsHandler) AddImage(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
	order, _ := strconv.ParseInt(c.FormValue("display_order"), 10, 64)
	isThumbnail := c.FormValue("is_thumbnail") == "1" // Checkbox sends "1" if checked

	// Image file is required
	fileHeader, err := c.FormFile("image")
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "Image file is required")
	}

	// Upload the image using the upload service
	path, err := h.uploadSvc.UploadProductImage(fileHeader)
	if err != nil {
		h.logger.Error("failed to upload image", "error", err)
		return echo.NewHTTPError(http.StatusBadRequest, "Failed to upload image: "+err.Error())
	}

	// Extract optional fields
	altText := c.FormValue("alt_text")
	caption := c.FormValue("caption")

	// Create database record for the image
	_, err = h.queries.CreateProductImage(ctx, sqlc.CreateProductImageParams{
		ProductID:    id,
		ImagePath:    path,                                                   // Stored path from upload service
		AltText:      sql.NullString{String: altText, Valid: altText != ""}, // Only store if provided
		Caption:      sql.NullString{String: caption, Valid: caption != ""}, // Only store if provided
		DisplayOrder: order,
		IsThumbnail:  isThumbnail,                                           // Boolean flag for thumbnail designation
	})
	if err != nil {
		h.logger.Error("failed to create image", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the activity for audit trail
	logActivity(c, "updated", "product", id, "", "Added image to Product #%d", id)

	// Return the refreshed images gallery
	return h.ListImages(c)
}

// DeleteImage handles DELETE requests to /admin/products/:id/images/:image_id
// Deletes a single image and returns the updated image gallery.
//
// URL Parameters:
//   - id: Product ID
//   - image_id: Specific image ID to delete
//
// HTMX: Returns updated image gallery fragment after deletion
//
// Note: This deletes a single image from the gallery. The actual image file
// may need manual cleanup from disk depending on storage configuration.
func (h *ProductDetailsHandler) DeleteImage(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
	imageID, _ := strconv.ParseInt(c.Param("image_id"), 10, 64)

	// Delete the specific image record
	if err := h.queries.DeleteProductImage(c.Request().Context(), imageID); err != nil {
		h.logger.Error("failed to delete image", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Log the deletion
	logActivity(c, "updated", "product", id, "", "Deleted image from Product #%d", id)

	// Return the refreshed images gallery
	return h.ListImages(c)
}
