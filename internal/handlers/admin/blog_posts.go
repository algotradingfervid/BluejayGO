package admin

import (
	// Standard library imports for data handling and HTTP operations
	"database/sql" // Handles SQL NULL types (NullString, NullInt64, NullTime)
	"fmt"          // String formatting for dynamic route paths
	"log/slog"     // Structured logging for error tracking and debugging
	"math"         // Math operations for pagination calculations (Ceil)
	"net/http"     // HTTP status codes and error responses
	"strconv"      // String to integer conversions for IDs and form values
	"strings"      // String manipulation for reading time calculation
	"time"         // Time parsing and formatting for published_at timestamps

	// Third-party framework imports
	"github.com/labstack/echo/v4" // Echo web framework for routing and context handling

	// Internal application imports
	"github.com/narendhupati/bluejay-cms/db/sqlc"           // Generated SQL queries via sqlc
	"github.com/narendhupati/bluejay-cms/internal/services" // Cache service for invalidating blog pages
)

// BlogPostsHandler manages all HTTP handlers for blog post CRUD operations.
// Handles listing with filters/pagination, create/edit forms, and product associations.
type BlogPostsHandler struct {
	queries *sqlc.Queries   // Database query interface generated by sqlc
	logger  *slog.Logger    // Structured logger for error tracking
	cache   *services.Cache // Cache service for invalidating blog-related pages
}

// NewBlogPostsHandler constructs a new BlogPostsHandler with required dependencies.
func NewBlogPostsHandler(queries *sqlc.Queries, logger *slog.Logger, cache *services.Cache) *BlogPostsHandler {
	return &BlogPostsHandler{queries: queries, logger: logger, cache: cache}
}

// blogPostsPerPage defines the number of blog posts displayed per page in the admin list view.
const blogPostsPerPage = 15

// List handles GET /admin/blog/posts
// Renders the main blog posts list page with filtering, search, and pagination.
// Template: admin/pages/blog_posts_list.html (full page)
// Query Params:
//   - search: text search across post titles and content
//   - status: filter by published/draft/scheduled
//   - category: filter by category ID
//   - author: filter by author ID
//   - page: pagination page number (default: 1)
func (h *BlogPostsHandler) List(c echo.Context) error {
	ctx := c.Request().Context()

	// Extract query parameters for filtering and pagination
	search := c.QueryParam("search")
	status := c.QueryParam("status")
	categoryStr := c.QueryParam("category")
	authorStr := c.QueryParam("author")
	pageStr := c.QueryParam("page")

	// Parse category and author IDs from query strings (default to 0 if empty)
	var categoryID int64
	if categoryStr != "" {
		categoryID, _ = strconv.ParseInt(categoryStr, 10, 64)
	}
	var authorID int64
	if authorStr != "" {
		authorID, _ = strconv.ParseInt(authorStr, 10, 64)
	}

	// Parse and validate page number, calculate offset for pagination
	page, _ := strconv.Atoi(pageStr)
	if page < 1 {
		page = 1
	}
	offset := int64((page - 1) * blogPostsPerPage)

	// Fetch filtered and paginated blog posts from the database
	posts, err := h.queries.ListBlogPostsAdminFiltered(ctx, sqlc.ListBlogPostsAdminFilteredParams{
		FilterStatus:   status,
		FilterCategory: categoryID,
		FilterAuthor:   authorID,
		FilterSearch:   search,
		PageLimit:      blogPostsPerPage,
		PageOffset:     offset,
	})
	if err != nil {
		h.logger.Error("failed to list blog posts", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Count total matching posts for pagination calculations
	total, err := h.queries.CountBlogPostsAdminFiltered(ctx, sqlc.CountBlogPostsAdminFilteredParams{
		FilterStatus:   status,
		FilterCategory: categoryID,
		FilterAuthor:   authorID,
		FilterSearch:   search,
	})
	if err != nil {
		h.logger.Error("failed to count blog posts", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Fetch categories and authors for filter dropdown options (ignore errors for non-critical data)
	categories, _ := h.queries.ListBlogCategories(ctx)
	authors, _ := h.queries.ListBlogAuthors(ctx)

	// Calculate total number of pages for pagination controls
	totalPages := int(math.Ceil(float64(total) / float64(blogPostsPerPage)))
	if totalPages < 1 {
		totalPages = 1
	}

	// Build array of page numbers for pagination UI
	var pages []int
	for i := 1; i <= totalPages; i++ {
		pages = append(pages, i)
	}

	// Calculate "Showing X-Y of Z" display values
	showFrom := offset + 1
	showTo := offset + int64(len(posts))
	if total == 0 {
		showFrom = 0 // Display "Showing 0-0 of 0" when no results
	}

	// Determine if any filters are active (used for "Clear Filters" button visibility)
	hasFilters := search != "" || status != "" || categoryStr != "" || authorStr != ""

	return c.Render(http.StatusOK, "admin/pages/blog_posts_list.html", map[string]interface{}{
		"Title":      "Manage Blog Posts",
		"Posts":      posts,
		"Categories": categories,
		"Authors":    authors,
		"Search":     search,
		"Status":     status,
		"CategoryID": categoryID,
		"AuthorID":   authorID,
		"HasFilters": hasFilters,
		"Page":       page,
		"TotalPages": totalPages,
		"Pages":      pages,
		"Total":      total,
		"ShowFrom":   showFrom,
		"ShowTo":     showTo,
	})
}

// New handles GET /admin/blog/posts/new
// Renders the create blog post form with empty fields.
// Template: admin/pages/blog_post_form.html (full page)
// Loads all categories, authors, and tags for dropdown/tag selection.
func (h *BlogPostsHandler) New(c echo.Context) error {
	ctx := c.Request().Context()
	// Fetch reference data for form dropdowns and tag selection
	categories, _ := h.queries.ListBlogCategories(ctx)
	authors, _ := h.queries.ListBlogAuthors(ctx)
	tags, _ := h.queries.ListAllBlogTags(ctx)
	return c.Render(http.StatusOK, "admin/pages/blog_post_form.html", map[string]interface{}{
		"Title":        "New Blog Post",
		"FormAction":   "/admin/blog/posts",
		"Item":         nil, // No existing post data
		"Categories":   categories,
		"Authors":      authors,
		"AllTags":      tags,
		"PostTags":     nil, // No tags selected yet
		"PostProducts": nil, // No products associated yet
	})
}

// calculateReadingTime estimates reading time based on word count.
// Assumes 200 words per minute reading speed, with a minimum of 1 minute.
// Used when reading_time_minutes is not manually provided in the form.
func calculateReadingTime(body string) int64 {
	words := len(strings.Fields(strings.TrimSpace(body)))
	minutes := words / 200
	if minutes < 1 {
		minutes = 1 // Always show at least 1 minute reading time
	}
	return int64(minutes)
}

// Create handles POST /admin/blog/posts
// Processes the blog post creation form submission.
// Handles tag associations, product associations, and automatic slug/reading time generation.
// Redirects to /admin/blog/posts on success.
func (h *BlogPostsHandler) Create(c echo.Context) error {
	ctx := c.Request().Context()

	// Extract basic post fields from form
	title := c.FormValue("title")
	slug := c.FormValue("slug")
	if slug == "" {
		slug = makeSlug(title) // Auto-generate slug from title if not provided
	}

	// Extract body and calculate reading time if not manually set
	body := c.FormValue("body")
	readingTime, _ := strconv.ParseInt(c.FormValue("reading_time_minutes"), 10, 64)
	if readingTime == 0 {
		readingTime = calculateReadingTime(body) // Auto-calculate based on word count
	}

	// Parse category and author IDs
	categoryID, _ := strconv.ParseInt(c.FormValue("category_id"), 10, 64)
	authorID, _ := strconv.ParseInt(c.FormValue("author_id"), 10, 64)

	// Extract optional fields for featured image, meta data, and excerpt
	featuredURL := c.FormValue("featured_image_url")
	featuredAlt := c.FormValue("featured_image_alt")
	metaDesc := c.FormValue("meta_description")
	excerpt := c.FormValue("excerpt")
	status := c.FormValue("status")

	// Set published_at timestamp only for published posts
	// If status is "published", parse the provided datetime or default to now
	var publishedAt sql.NullTime
	if status == "published" {
		pubStr := c.FormValue("published_at")
		if t, err := time.Parse("2006-01-02T15:04", pubStr); err == nil {
			publishedAt = sql.NullTime{Time: t, Valid: true}
		} else {
			publishedAt = sql.NullTime{Time: time.Now(), Valid: true} // Default to current time
		}
	}

	// Insert the blog post into the database
	post, err := h.queries.CreateBlogPost(ctx, sqlc.CreateBlogPostParams{
		Title:              title,
		Slug:               slug,
		Excerpt:            excerpt,
		Body:               body,
		FeaturedImageUrl:   sql.NullString{String: featuredURL, Valid: featuredURL != ""},
		FeaturedImageAlt:   sql.NullString{String: featuredAlt, Valid: featuredAlt != ""},
		CategoryID:         categoryID,
		AuthorID:           authorID,
		MetaDescription:    sql.NullString{String: metaDesc, Valid: metaDesc != ""},
		ReadingTimeMinutes: sql.NullInt64{Int64: readingTime, Valid: readingTime > 0},
		Status:             status,
		PublishedAt:        publishedAt,
	})
	if err != nil {
		h.logger.Error("failed to create blog post", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Handle tag associations - form returns tag_ids[] array
	// Each tag ID creates a row in the blog_post_tags junction table
	tagIDs := c.Request().Form["tag_ids"]
	for _, tagIDStr := range tagIDs {
		tagID, _ := strconv.ParseInt(tagIDStr, 10, 64)
		if tagID > 0 {
			h.queries.AddTagToPost(ctx, sqlc.AddTagToPostParams{
				BlogPostID: post.ID,
				BlogTagID:  tagID,
			})
		}
	}

	// Handle product associations - form returns product_ids[] array
	// Display order is determined by the order in the form submission
	productIDs := c.Request().Form["product_ids"]
	for i, pidStr := range productIDs {
		pid, _ := strconv.ParseInt(pidStr, 10, 64)
		if pid > 0 {
			h.queries.AddProductToPost(ctx, sqlc.AddProductToPostParams{
				BlogPostID:   post.ID,
				ProductID:    pid,
				DisplayOrder: sql.NullInt64{Int64: int64(i), Valid: true},
			})
		}
	}

	// Invalidate all blog-related cache entries since new content was created
	h.cache.DeleteByPrefix("page:blog")
	logActivity(c, "created", "blog_post", 0, title, "Created blog_post '%s'", title)
	return c.Redirect(http.StatusSeeOther, "/admin/blog/posts")
}

// Edit handles GET /admin/blog/posts/:id/edit
// Renders the edit blog post form pre-filled with existing post data.
// Template: admin/pages/blog_post_form.html (full page)
// Loads existing tags and products associated with this post for editing.
func (h *BlogPostsHandler) Edit(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch the existing post or return 404 if not found
	post, err := h.queries.GetBlogPost(ctx, id)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound, "Post not found")
	}

	// Fetch all reference data for dropdowns and tag selection
	categories, _ := h.queries.ListBlogCategories(ctx)
	authors, _ := h.queries.ListBlogAuthors(ctx)
	allTags, _ := h.queries.ListAllBlogTags(ctx)

	// Fetch existing associations for this specific post
	postTags, _ := h.queries.GetPostTagsByPostID(ctx, id)
	postProducts, _ := h.queries.GetPostProductsByPostID(ctx, id)

	return c.Render(http.StatusOK, "admin/pages/blog_post_form.html", map[string]interface{}{
		"Title":        "Edit Blog Post",
		"FormAction":   fmt.Sprintf("/admin/blog/posts/%d", id),
		"Item":         post,         // Existing post data
		"Categories":   categories,
		"Authors":      authors,
		"AllTags":      allTags,
		"PostTags":     postTags,     // Currently selected tags
		"PostProducts": postProducts, // Currently associated products
	})
}

// Update handles POST /admin/blog/posts/:id
// Processes the blog post update form submission.
// Uses "clear and re-add" strategy for tags and products to handle removed associations.
// Preserves existing published_at timestamp unless transitioning from draft to published.
// Redirects to /admin/blog/posts on success.
func (h *BlogPostsHandler) Update(c echo.Context) error {
	ctx := c.Request().Context()
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Fetch existing post to preserve published_at and verify existence
	existing, err := h.queries.GetBlogPost(ctx, id)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound, "Post not found")
	}

	// Extract and process form values (same as Create handler)
	title := c.FormValue("title")
	slug := c.FormValue("slug")
	if slug == "" {
		slug = makeSlug(title) // Auto-generate slug if not provided
	}

	body := c.FormValue("body")
	readingTime, _ := strconv.ParseInt(c.FormValue("reading_time_minutes"), 10, 64)
	if readingTime == 0 {
		readingTime = calculateReadingTime(body) // Auto-calculate if not manually set
	}

	categoryID, _ := strconv.ParseInt(c.FormValue("category_id"), 10, 64)
	authorID, _ := strconv.ParseInt(c.FormValue("author_id"), 10, 64)

	featuredURL := c.FormValue("featured_image_url")
	featuredAlt := c.FormValue("featured_image_alt")
	metaDesc := c.FormValue("meta_description")
	excerpt := c.FormValue("excerpt")
	status := c.FormValue("status")

	// Preserve existing published_at unless transitioning from draft/scheduled to published
	// Only set published_at when first publishing the post
	publishedAt := existing.PublishedAt
	if status == "published" && !existing.PublishedAt.Valid {
		pubStr := c.FormValue("published_at")
		if t, err := time.Parse("2006-01-02T15:04", pubStr); err == nil {
			publishedAt = sql.NullTime{Time: t, Valid: true}
		} else {
			publishedAt = sql.NullTime{Time: time.Now(), Valid: true} // Default to now
		}
	}

	// Update the blog post in the database
	_, err = h.queries.UpdateBlogPost(ctx, sqlc.UpdateBlogPostParams{
		ID:                 id,
		Title:              title,
		Slug:               slug,
		Excerpt:            excerpt,
		Body:               body,
		FeaturedImageUrl:   sql.NullString{String: featuredURL, Valid: featuredURL != ""},
		FeaturedImageAlt:   sql.NullString{String: featuredAlt, Valid: featuredAlt != ""},
		CategoryID:         categoryID,
		AuthorID:           authorID,
		MetaDescription:    sql.NullString{String: metaDesc, Valid: metaDesc != ""},
		ReadingTimeMinutes: sql.NullInt64{Int64: readingTime, Valid: readingTime > 0},
		Status:             status,
		PublishedAt:        publishedAt,
	})
	if err != nil {
		h.logger.Error("failed to update blog post", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Update tag associations using "clear and re-add" strategy
	// This handles both newly added tags and removed tags in one operation
	h.queries.ClearPostTags(ctx, id)
	tagIDs := c.Request().Form["tag_ids"]
	for _, tagIDStr := range tagIDs {
		tagID, _ := strconv.ParseInt(tagIDStr, 10, 64)
		if tagID > 0 {
			h.queries.AddTagToPost(ctx, sqlc.AddTagToPostParams{
				BlogPostID: id,
				BlogTagID:  tagID,
			})
		}
	}

	// Update product associations using "clear and re-add" strategy
	// Display order is recalculated based on new form submission order
	h.queries.ClearPostProducts(ctx, id)
	productIDs := c.Request().Form["product_ids"]
	for i, pidStr := range productIDs {
		pid, _ := strconv.ParseInt(pidStr, 10, 64)
		if pid > 0 {
			h.queries.AddProductToPost(ctx, sqlc.AddProductToPostParams{
				BlogPostID:   id,
				ProductID:    pid,
				DisplayOrder: sql.NullInt64{Int64: int64(i), Valid: true},
			})
		}
	}

	// Invalidate all blog-related cache entries since content was modified
	h.cache.DeleteByPrefix("page:blog")
	logActivity(c, "updated", "blog_post", id, title, "Updated blog_post '%s'", title)
	return c.Redirect(http.StatusSeeOther, "/admin/blog/posts")
}

// Delete handles DELETE /admin/blog/posts/:id
// Deletes a blog post and all associated tags and products.
// HTMX behavior: Returns 200 OK with no content, triggering client-side row removal.
// Must clear associations first due to foreign key constraints.
func (h *BlogPostsHandler) Delete(c echo.Context) error {
	id, _ := strconv.ParseInt(c.Param("id"), 10, 64)

	// Clear associations first to avoid foreign key constraint violations
	h.queries.ClearPostProducts(c.Request().Context(), id)
	h.queries.ClearPostTags(c.Request().Context(), id)

	// Delete the blog post itself
	if err := h.queries.DeleteBlogPost(c.Request().Context(), id); err != nil {
		h.logger.Error("failed to delete blog post", "error", err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	// Invalidate blog cache since content was removed
	h.cache.DeleteByPrefix("page:blog")
	logActivity(c, "deleted", "blog_post", id, "", "Deleted blog_post #%d", id)

	// Return empty 200 OK response for HTMX to process
	return c.NoContent(http.StatusOK)
}

// SearchProducts handles GET /admin/blog/posts/products/search?_product_search=query
// Returns an HTML fragment with product suggestions for HTMX-powered autocomplete.
// HTMX behavior: Returns HTML partial, not full page. Target: product suggestions container.
// Template: admin/partials/product_suggestions.html (HTML fragment)
// Used in blog post form to associate products with posts.
func (h *BlogPostsHandler) SearchProducts(c echo.Context) error {
	q := strings.TrimSpace(c.QueryParam("_product_search"))

	// Return empty suggestions if query is blank
	if q == "" {
		return c.Render(http.StatusOK, "admin/partials/product_suggestions.html", map[string]interface{}{
			"Products": nil,
			"Query":    "",
		})
	}

	// Search for published products matching the query (LIKE search with wildcards)
	products, _ := h.queries.SearchPublishedProducts(c.Request().Context(), "%"+q+"%")

	// Render product suggestions as HTML fragment for HTMX to inject into DOM
	return c.Render(http.StatusOK, "admin/partials/product_suggestions.html", map[string]interface{}{
		"Products": products,
		"Query":    q,
	})
}
