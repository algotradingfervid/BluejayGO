// Package admin provides HTTP handlers for the Contact section of the admin panel.
// This includes managing contact form submissions and office locations.
package admin

import (
	// Standard library imports
	"database/sql" // SQL types for handling nullable database fields
	"fmt"          // String formatting for building dynamic routes and messages
	"log/slog"     // Structured logging for error and event tracking
	"math"         // Mathematical operations for pagination calculations
	"net/http"     // HTTP status codes and request/response handling
	"strconv"      // String to int64 conversions for form values and URL params

	// Third-party imports
	"github.com/labstack/echo/v4" // Echo web framework for routing and context

	// Internal imports
	"github.com/narendhupati/bluejay-cms/db/sqlc"          // Generated sqlc queries for database operations
	"github.com/narendhupati/bluejay-cms/internal/services" // Cache service for invalidating page caches
)

// AdminContactHandler manages all admin operations related to contact form submissions
// and office locations. It handles viewing, filtering, status updates, and deletion
// of contact submissions, as well as CRUD operations for office locations.
type AdminContactHandler struct {
	queries *sqlc.Queries    // Database query interface generated by sqlc
	logger  *slog.Logger     // Structured logger for error and event logging
	cache   *services.Cache  // Cache service for invalidating page-level caches
}

// NewAdminContactHandler creates a new AdminContactHandler instance with required dependencies.
// Parameters:
//   - queries: sqlc-generated database query interface
//   - logger: structured logger for error and event tracking
//   - cache: cache service for page invalidation
func NewAdminContactHandler(queries *sqlc.Queries, logger *slog.Logger, cache *services.Cache) *AdminContactHandler {
	return &AdminContactHandler{
		queries: queries,
		logger:  logger,
		cache:   cache,
	}
}

// ==================== CONTACT SUBMISSIONS ====================
// Contact submissions are form entries from the public-facing contact page.
// Each submission includes name, email, phone, company, inquiry type, message,
// status (new/reviewed/responded/archived), and submission type (contact/rfq).

// ListSubmissions displays all contact form submissions with pagination and filtering.
// HTTP Method: GET
// Route: /admin/contact/submissions
// Template: admin/pages/contact_submissions_list.html (full page)
// HTMX: Not used - returns full page render
//
// This handler supports complex filtering and pagination:
// - Query params: page (pagination), status (filter by status), type (filter by submission type), search (text search)
// - Implements multiple query strategies based on filter combination
// - Calculates pagination metadata and tab counts for the UI
func (h *AdminContactHandler) ListSubmissions(c echo.Context) error {
	// Parse pagination parameter from query string, default to page 1
	page := int64(1)
	if v := c.QueryParam("page"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil && parsed > 0 {
			page = parsed
		}
	}

	// Set items per page and calculate offset for SQL LIMIT/OFFSET
	perPage := int64(25)
	offset := (page - 1) * perPage

	// Extract filter parameters from query string
	status := c.QueryParam("status")               // Filter by status: new/reviewed/responded/archived
	submissionType := c.QueryParam("type")         // Filter by type: contact/rfq
	search := c.QueryParam("search")               // Full-text search across multiple fields

	ctx := c.Request().Context()

	// Collect counts for filter tabs in the UI
	// These provide badge counts for All/Contact/RFQ tabs and new submissions indicator
	totalAll, _ := h.queries.CountContactSubmissions(ctx)
	totalContact, _ := h.queries.CountContactSubmissionsByType(ctx, "contact")
	totalRFQ, _ := h.queries.CountContactSubmissionsByType(ctx, "rfq")
	newCount, _ := h.queries.CountContactSubmissionsByStatus(ctx, "new")

	// Submissions slice will hold the query results
	var submissions []listSubmissionRow
	var totalCount int64

	// Execute different queries based on filter combination
	// This implements a branching query strategy for optimal SQL performance

	if search != "" {
		// SEARCH QUERY: Full-text search across name, email, phone, and company fields
		// Wrap search string in sql.NullString for sqlc parameter binding
		searchParam := sql.NullString{String: search, Valid: true}

		// Execute search query with same search term applied to 4 columns
		items, err := h.queries.SearchContactSubmissions(ctx, sqlc.SearchContactSubmissionsParams{
			Column1: searchParam, // Searches name field
			Column2: searchParam, // Searches email field
			Column3: searchParam, // Searches phone field
			Column4: searchParam, // Searches company field
			Limit:   perPage,
			Offset:  offset,
		})
		if err != nil {
			h.logger.Error("Failed to search contact submissions", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to load submissions")
		}

		// Convert sqlc-generated struct to internal list row struct
		for _, item := range items {
			submissions = append(submissions, listSubmissionRow{
				ID: item.ID, Name: item.Name, Email: item.Email, Phone: item.Phone,
				Company: item.Company, InquiryType: item.InquiryType, Status: item.Status,
				SubmissionType: item.SubmissionType, CreatedAt: item.CreatedAt,
			})
		}

		// Get total count for pagination (matching search criteria)
		cnt, _ := h.queries.CountContactSubmissionsSearch(ctx, sqlc.CountContactSubmissionsSearchParams{
			Column1: searchParam, Column2: searchParam, Column3: searchParam, Column4: searchParam,
		})
		totalCount = cnt
	} else if status != "" && submissionType != "" {
		// COMBINED FILTER: Both status AND type filters active
		items, err := h.queries.ListContactSubmissionsByStatusAndType(ctx, sqlc.ListContactSubmissionsByStatusAndTypeParams{
			Status: status, SubmissionType: submissionType, Limit: perPage, Offset: offset,
		})
		if err != nil {
			h.logger.Error("Failed to list contact submissions", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to load submissions")
		}
		for _, item := range items {
			submissions = append(submissions, listSubmissionRow{
				ID: item.ID, Name: item.Name, Email: item.Email, Phone: item.Phone,
				Company: item.Company, InquiryType: item.InquiryType, Status: item.Status,
				SubmissionType: item.SubmissionType, CreatedAt: item.CreatedAt,
			})
		}
		cnt, _ := h.queries.CountContactSubmissionsByStatusAndType(ctx, sqlc.CountContactSubmissionsByStatusAndTypeParams{
			Status: status, SubmissionType: submissionType,
		})
		totalCount = cnt
	} else if status != "" {
		// STATUS FILTER ONLY: Filter by status (new/reviewed/responded/archived)
		items, err := h.queries.ListContactSubmissionsByStatus(ctx, sqlc.ListContactSubmissionsByStatusParams{
			Status: status, Limit: perPage, Offset: offset,
		})
		if err != nil {
			h.logger.Error("Failed to list contact submissions", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to load submissions")
		}
		for _, item := range items {
			submissions = append(submissions, listSubmissionRow{
				ID: item.ID, Name: item.Name, Email: item.Email, Phone: item.Phone,
				Company: item.Company, InquiryType: item.InquiryType, Status: item.Status,
				SubmissionType: item.SubmissionType, CreatedAt: item.CreatedAt,
			})
		}
		cnt, _ := h.queries.CountContactSubmissionsByStatus(ctx, status)
		totalCount = cnt
	} else if submissionType != "" {
		// TYPE FILTER ONLY: Filter by submission type (contact/rfq)
		items, err := h.queries.ListContactSubmissionsByType(ctx, sqlc.ListContactSubmissionsByTypeParams{
			SubmissionType: submissionType, Limit: perPage, Offset: offset,
		})
		if err != nil {
			h.logger.Error("Failed to list contact submissions", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to load submissions")
		}
		for _, item := range items {
			submissions = append(submissions, listSubmissionRow{
				ID: item.ID, Name: item.Name, Email: item.Email, Phone: item.Phone,
				Company: item.Company, InquiryType: item.InquiryType, Status: item.Status,
				SubmissionType: item.SubmissionType, CreatedAt: item.CreatedAt,
			})
		}
		cnt, _ := h.queries.CountContactSubmissionsByType(ctx, submissionType)
		totalCount = cnt
	} else {
		// NO FILTERS: List all submissions with pagination only
		items, err := h.queries.ListContactSubmissions(ctx, sqlc.ListContactSubmissionsParams{
			Limit: perPage, Offset: offset,
		})
		if err != nil {
			h.logger.Error("Failed to list contact submissions", "error", err)
			return c.String(http.StatusInternalServerError, "Failed to load submissions")
		}
		for _, item := range items {
			submissions = append(submissions, listSubmissionRow{
				ID: item.ID, Name: item.Name, Email: item.Email, Phone: item.Phone,
				Company: item.Company, InquiryType: item.InquiryType, Status: item.Status,
				SubmissionType: item.SubmissionType, CreatedAt: item.CreatedAt,
			})
		}
		totalCount = totalAll
	}

	// Calculate total pages for pagination controls using ceiling division
	totalPages := int64(math.Ceil(float64(totalCount) / float64(perPage)))

	// Render the list page with submissions data and filter/pagination metadata
	return c.Render(http.StatusOK, "admin/pages/contact_submissions_list.html", map[string]interface{}{
		"Title":        "Contact Submissions",
		"Submissions":  submissions,      // Filtered and paginated submissions
		"Page":         page,              // Current page number
		"TotalPages":   totalPages,        // Total pages for pagination controls
		"TotalCount":   totalCount,        // Total count of filtered results
		"Status":       status,            // Active status filter (for UI state)
		"Type":         submissionType,    // Active type filter (for UI state)
		"Search":       search,            // Active search term (for UI state)
		"TotalAll":     totalAll,          // Badge count for "All" tab
		"TotalContact": totalContact,      // Badge count for "Contact" tab
		"TotalRFQ":     totalRFQ,          // Badge count for "RFQ" tab
		"NewCount":     newCount,          // Badge count for new submissions
	})
}

// listSubmissionRow is an internal struct for holding submission list data.
// It normalizes the different sqlc-generated query result structs into a
// common format for template rendering.
type listSubmissionRow struct {
	ID             int64          // Primary key
	Name           string         // Submitter name
	Email          string         // Submitter email
	Phone          string         // Submitter phone
	Company        string         // Submitter company
	InquiryType    sql.NullString // Optional inquiry type/category
	Status         string         // Submission status (new/reviewed/responded/archived)
	SubmissionType string         // Type of submission (contact/rfq)
	CreatedAt      interface{}    // Timestamp of submission
}

// ViewSubmission displays a single contact submission in detail view.
// HTTP Method: GET
// Route: /admin/contact/submissions/:id
// Template: admin/pages/contact_submission_detail.html (full page)
// HTMX: Not used - returns full page render
//
// This handler retrieves a specific submission by ID and provides prev/next
// navigation IDs for browsing through submissions sequentially.
func (h *AdminContactHandler) ViewSubmission(c echo.Context) error {
	// Parse submission ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid submission ID")
	}

	ctx := c.Request().Context()

	// Fetch the full submission record from database
	submission, err := h.queries.GetContactSubmissionByID(ctx, id)
	if err != nil {
		h.logger.Error("Failed to get contact submission", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load submission")
	}

	// Get prev/next submission IDs for keyboard navigation arrows
	// Allows admin to quickly browse through submissions without returning to list
	prevID := int64(0)
	nextID := int64(0)
	if pid, err := h.queries.GetPreviousSubmissionID(ctx, id); err == nil {
		prevID = pid
	}
	if nid, err := h.queries.GetNextSubmissionID(ctx, id); err == nil {
		nextID = nid
	}

	// Render detail page with submission data and navigation IDs
	return c.Render(http.StatusOK, "admin/pages/contact_submission_detail.html", map[string]interface{}{
		"Title":      "Contact Submission",
		"Submission": submission,
		"PrevID":     prevID, // 0 if at beginning of list
		"NextID":     nextID, // 0 if at end of list
	})
}

// UpdateSubmissionStatus updates the status and notes of a contact submission.
// HTTP Method: POST
// Route: /admin/contact/submissions/:id/status
// Template: None - redirects to GET /admin/contact/submissions/:id
// HTMX: Not used - standard form submission with redirect
//
// This handler allows changing the submission status (new → reviewed → responded → archived)
// and optionally adding internal notes visible only to admins.
func (h *AdminContactHandler) UpdateSubmissionStatus(c echo.Context) error {
	// Parse submission ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid submission ID")
	}

	// Extract status and notes from form submission
	status := c.FormValue("status") // e.g., "reviewed", "responded", "archived"
	notes := c.FormValue("notes")   // Optional internal notes

	// Update the submission status and notes in database
	err = h.queries.UpdateContactSubmissionStatus(c.Request().Context(), sqlc.UpdateContactSubmissionStatusParams{
		Status: status,
		Notes:  sql.NullString{String: notes, Valid: notes != ""}, // NULL if notes are empty
		ID:     id,
	})
	if err != nil {
		h.logger.Error("Failed to update submission status", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to update status")
	}

	// Log the status update activity for audit trail
	logActivity(c, "updated", "contact_submission", id, "", "Updated Contact Submission #%d status", id)

	// Redirect back to the submission detail page
	return c.Redirect(http.StatusSeeOther, "/admin/contact/submissions/"+c.Param("id"))
}

// BulkMarkRead marks all new submissions as read/reviewed in a single operation.
// HTTP Method: POST
// Route: /admin/contact/submissions/bulk-mark-read
// Template: None - redirects to GET /admin/contact/submissions
// HTMX: Not used - standard form submission with redirect
//
// This is a bulk operation that updates all submissions with status="new" to status="reviewed".
// Useful for clearing the "new submissions" badge when reviewing multiple items at once.
func (h *AdminContactHandler) BulkMarkRead(c echo.Context) error {
	// Update all submissions with status="new" to status="reviewed"
	err := h.queries.BulkMarkContactSubmissionsRead(c.Request().Context())
	if err != nil {
		h.logger.Error("Failed to bulk mark submissions as read", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to update")
	}

	// Redirect back to the submissions list
	return c.Redirect(http.StatusSeeOther, "/admin/contact/submissions")
}

// DeleteSubmission handles deletion of a contact submission.
// HTTP Method: DELETE
// Route: /admin/contact/submissions/:id
// Template: None - returns HTTP 200 with no content (HTMX delete pattern)
// HTMX: Used - returns empty response, HTMX removes element from DOM
//
// This permanently deletes a contact submission from the database.
func (h *AdminContactHandler) DeleteSubmission(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid submission ID")
	}

	// Permanently delete the submission from database
	err = h.queries.DeleteContactSubmission(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to delete contact submission", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to delete submission")
	}

	// Log the deletion activity for audit trail
	logActivity(c, "deleted", "contact_submission", id, "", "Deleted Contact Submission #%d", id)

	// Return 200 OK with no content - HTMX will handle DOM removal
	return c.NoContent(http.StatusOK)
}

// ==================== OFFICE LOCATIONS ====================
// Office locations represent physical company offices displayed on the contact page.
// Each location has address, phone, email, is_primary flag, is_active flag, and display order.

// ListOffices displays all office locations in a list view.
// HTTP Method: GET
// Route: /admin/contact/offices
// Template: admin/pages/office_locations_list.html (full page)
// HTMX: Not used - returns full page render
func (h *AdminContactHandler) ListOffices(c echo.Context) error {
	// Fetch all office locations from database, ordered by display_order
	offices, err := h.queries.ListAllOfficeLocations(c.Request().Context())
	if err != nil {
		h.logger.Error("Failed to list office locations", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load offices")
	}

	// Render the list template with all office locations
	return c.Render(http.StatusOK, "admin/pages/office_locations_list.html", map[string]interface{}{
		"Title":   "Office Locations",
		"Offices": offices,
	})
}

// NewOffice displays the form for creating a new office location.
// HTTP Method: GET
// Route: /admin/contact/offices/new
// Template: admin/pages/office_locations_form.html (full page)
// HTMX: Not used - returns full page render
func (h *AdminContactHandler) NewOffice(c echo.Context) error {
	return c.Render(http.StatusOK, "admin/pages/office_locations_form.html", map[string]interface{}{
		"Title":      "New Office Location",
		"FormAction": "/admin/contact/offices",
		"Item":       nil,
		"IsNew":      true, // Flag for template to show "Create" vs "Update" button
	})
}

// CreateOffice handles office location creation.
// HTTP Method: POST
// Route: /admin/contact/offices
// Template: None - redirects to GET /admin/contact/offices
// HTMX: Not used - standard form submission with redirect
//
// This handler creates a new office location with full address, contact info,
// and flags for primary/active status. If marked as primary, it automatically
// unsets the primary flag on all other offices to ensure only one primary location.
func (h *AdminContactHandler) CreateOffice(c echo.Context) error {
	// Extract all address and contact form fields
	name := c.FormValue("name")                 // Office name (e.g., "Headquarters")
	addressLine1 := c.FormValue("address_line1") // Street address
	addressLine2 := c.FormValue("address_line2") // Suite/building/floor (optional)
	city := c.FormValue("city")
	state := c.FormValue("state")                // State/province
	postalCode := c.FormValue("postal_code")     // ZIP/postal code
	country := c.FormValue("country")
	phone := c.FormValue("phone")                // Office phone number
	email := c.FormValue("email")                // Office email
	mapURL := c.FormValue("map_url")
	_ = mapURL // map_url not in DB yet, placeholder for future feature

	// Convert checkbox values to SQLite integer booleans (0 or 1)
	isPrimary := int64(0)
	if v := c.FormValue("is_primary"); v == "on" || v == "1" {
		isPrimary = 1 // Mark as primary location (shown first on contact page)
	}

	isActive := int64(0)
	if v := c.FormValue("is_active"); v == "on" || v == "1" {
		isActive = 1 // Active offices are displayed on public contact page
	}

	// Parse display order with default of 0 if empty or invalid
	displayOrder := int64(0)
	if v := c.FormValue("display_order"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			displayOrder = parsed
		}
	}

	// Enforce single primary location constraint
	// If this office is being marked as primary, unset primary flag on all others
	if isPrimary == 1 {
		err := h.queries.UnsetPrimaryOfficeLocations(c.Request().Context())
		if err != nil {
			h.logger.Error("Failed to unset primary office locations", "error", err)
		}
	}

	// Build parameters for office creation
	// addressLine2, phone, and email are optional and use sql.NullString
	params := sqlc.CreateOfficeLocationParams{
		Name:         name,
		AddressLine1: addressLine1,
		AddressLine2: sql.NullString{String: addressLine2, Valid: addressLine2 != ""},
		City:         city,
		State:        state,
		PostalCode:   postalCode,
		Country:      country,
		Phone:        sql.NullString{String: phone, Valid: phone != ""},
		Email:        sql.NullString{String: email, Valid: email != ""},
		IsPrimary:    isPrimary,
		IsActive:     isActive,
		DisplayOrder: displayOrder,
	}

	// Insert the new office location into database
	_, err := h.queries.CreateOfficeLocation(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to create office location", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to create office")
	}

	// Invalidate cached Contact page content
	h.cache.DeleteByPrefix("page:contact")

	// Log the creation activity with office name
	logActivity(c, "created", "office", 0, c.FormValue("name"), "Created Office '%s'", c.FormValue("name"))

	// Redirect to the office locations list
	return c.Redirect(http.StatusSeeOther, "/admin/contact/offices")
}

// EditOffice displays the form for editing an existing office location.
// HTTP Method: GET
// Route: /admin/contact/offices/:id/edit
// Template: admin/pages/office_locations_form.html (full page)
// HTMX: Not used - returns full page render
func (h *AdminContactHandler) EditOffice(c echo.Context) error {
	// Parse office ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid office ID")
	}

	// Fetch the existing office location from database
	office, err := h.queries.GetOfficeLocationByID(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get office location", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load office")
	}

	// Render the form template with existing office data
	return c.Render(http.StatusOK, "admin/pages/office_locations_form.html", map[string]interface{}{
		"Title":      "Edit Office Location",
		"FormAction": fmt.Sprintf("/admin/contact/offices/%d", id), // POST destination
		"Item":       office,                                       // Existing data for pre-filling form
		"IsNew":      false,                                        // Flag for template to show "Update" button
	})
}

// UpdateOffice handles office location updates.
// HTTP Method: POST
// Route: /admin/contact/offices/:id
// Template: None - redirects to GET /admin/contact/offices
// HTMX: Not used - standard form submission with redirect
//
// This handler updates an existing office location. Like CreateOffice,
// it enforces the single primary location constraint.
func (h *AdminContactHandler) UpdateOffice(c echo.Context) error {
	// Parse office ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid office ID")
	}

	// Extract all form fields (same as CreateOffice)
	name := c.FormValue("name")
	addressLine1 := c.FormValue("address_line1")
	addressLine2 := c.FormValue("address_line2")
	city := c.FormValue("city")
	state := c.FormValue("state")
	postalCode := c.FormValue("postal_code")
	country := c.FormValue("country")
	phone := c.FormValue("phone")
	email := c.FormValue("email")

	// Convert checkbox values to integer booleans
	isPrimary := int64(0)
	if v := c.FormValue("is_primary"); v == "on" || v == "1" {
		isPrimary = 1
	}

	isActive := int64(0)
	if v := c.FormValue("is_active"); v == "on" || v == "1" {
		isActive = 1
	}

	displayOrder := int64(0)
	if v := c.FormValue("display_order"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			displayOrder = parsed
		}
	}

	// Enforce single primary location constraint (same as CreateOffice)
	if isPrimary == 1 {
		err := h.queries.UnsetPrimaryOfficeLocations(c.Request().Context())
		if err != nil {
			h.logger.Error("Failed to unset primary office locations", "error", err)
		}
	}

	// Build parameters for office update
	params := sqlc.UpdateOfficeLocationParams{
		Name:         name,
		AddressLine1: addressLine1,
		AddressLine2: sql.NullString{String: addressLine2, Valid: addressLine2 != ""},
		City:         city,
		State:        state,
		PostalCode:   postalCode,
		Country:      country,
		Phone:        sql.NullString{String: phone, Valid: phone != ""},
		Email:        sql.NullString{String: email, Valid: email != ""},
		IsPrimary:    isPrimary,
		IsActive:     isActive,
		DisplayOrder: displayOrder,
		ID:           id, // WHERE clause identifier
	}

	// Update the existing office location in database
	err = h.queries.UpdateOfficeLocation(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to update office location", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to update office")
	}

	// Invalidate cached Contact page content
	h.cache.DeleteByPrefix("page:contact")

	// Log the update activity with office ID and name
	logActivity(c, "updated", "office", id, c.FormValue("name"), "Updated Office '%s'", c.FormValue("name"))

	// Redirect to the office locations list
	return c.Redirect(http.StatusSeeOther, "/admin/contact/offices")
}

// DeleteOffice handles deletion of an office location.
// HTTP Method: DELETE
// Route: /admin/contact/offices/:id
// Template: None - returns HTTP 200 with no content (HTMX delete pattern)
// HTMX: Used - returns empty response, HTMX removes element from DOM
func (h *AdminContactHandler) DeleteOffice(c echo.Context) error {
	// Parse office ID from URL parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid office ID")
	}

	// Permanently delete the office location from database
	err = h.queries.DeleteOfficeLocation(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to delete office location", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to delete office")
	}

	// Invalidate cached Contact page content
	h.cache.DeleteByPrefix("page:contact")

	// Log the deletion activity with office ID
	logActivity(c, "deleted", "office", id, "", "Deleted Office #%d", id)

	// Return 200 OK with no content - HTMX will handle DOM removal
	return c.NoContent(http.StatusOK)
}
