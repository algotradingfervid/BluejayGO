// Package admin provides HTTP handlers for the admin panel content management features.
// This file contains handlers for managing Solutions â€” business solutions offered to clients.
package admin

import (
	// Standard library imports
	"database/sql"   // Used for nullable SQL types (NullString, NullInt64, NullBool)
	"log/slog"       // Structured logging for error tracking and debugging
	"math"           // Used for math.Ceil to calculate total pages from item count
	"net/http"       // HTTP status codes for responses
	"strconv"        // String to integer conversions for route params and form values

	// Third-party imports
	"github.com/labstack/echo/v4" // Echo web framework for HTTP routing and context handling

	// Internal imports
	"github.com/narendhupati/bluejay-cms/db/sqlc"           // Generated SQL queries from sqlc
	"github.com/narendhupati/bluejay-cms/internal/services" // Service layer including cache implementation
)

// solutionsPerPage defines the number of solutions to display per page in the list view.
const solutionsPerPage = 15

// SolutionsHandler handles all HTTP requests for solutions management in the admin panel.
// It manages CRUD operations for solutions and their related resources (stats, challenges, products, CTAs).
type SolutionsHandler struct {
	queries *sqlc.Queries   // Database query interface generated by sqlc
	logger  *slog.Logger    // Structured logger for error tracking
	cache   *services.Cache // Cache service for invalidating page cache after updates
}

// NewSolutionsHandler creates and initializes a new SolutionsHandler with required dependencies.
// Parameters:
//   - queries: sqlc-generated database query interface
//   - logger: structured logger for error logging
//   - cache: cache service for cache invalidation
//
// Returns a fully initialized SolutionsHandler ready to handle HTTP requests.
func NewSolutionsHandler(queries *sqlc.Queries, logger *slog.Logger, cache *services.Cache) *SolutionsHandler {
	return &SolutionsHandler{
		queries: queries,
		logger:  logger,
		cache:   cache,
	}
}

// List displays all solutions with filtering and pagination.
//
// HTTP Method: GET
// Route: /admin/solutions
// Template: admin/pages/solutions_list.html (full page render)
// HTMX: No - returns full page
//
// Query Parameters:
//   - search: Filter solutions by title or description (text search)
//   - status: Filter by publication status ("published", "draft", or empty for all)
//   - page: Current page number (default: 1)
//
// This handler retrieves a paginated list of solutions, applies filters, and renders
// the solutions list page with pagination controls. It calculates total pages and
// provides range information (showing X-Y of Z results).
func (h *SolutionsHandler) List(c echo.Context) error {
	ctx := c.Request().Context()

	// Extract filter parameters from query string
	search := c.QueryParam("search") // Text search across title/description
	status := c.QueryParam("status") // Publication status filter
	pageStr := c.QueryParam("page")  // Current page number

	// Parse and validate page number - default to page 1 if invalid or missing
	page, _ := strconv.Atoi(pageStr)
	if page < 1 {
		page = 1
	}
	// Calculate database offset for pagination (zero-indexed)
	offset := int64((page - 1) * solutionsPerPage)

	// Query database for filtered and paginated solutions
	solutions, err := h.queries.ListSolutionsAdminFiltered(ctx, sqlc.ListSolutionsAdminFilteredParams{
		FilterStatus: status,
		FilterSearch: search,
		PageLimit:    solutionsPerPage,
		PageOffset:   offset,
	})
	if err != nil {
		h.logger.Error("Failed to list solutions", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load solutions")
	}

	// Get total count of solutions matching filters for pagination calculation
	total, err := h.queries.CountSolutionsAdminFiltered(ctx, sqlc.CountSolutionsAdminFilteredParams{
		FilterStatus: status,
		FilterSearch: search,
	})
	if err != nil {
		h.logger.Error("Failed to count solutions", "error", err)
		total = 0 // Graceful degradation - pagination will show 1 page
	}

	// Calculate total number of pages (rounded up)
	totalPages := int(math.Ceil(float64(total) / float64(solutionsPerPage)))
	if totalPages < 1 {
		totalPages = 1 // Always show at least 1 page
	}

	// Build array of page numbers for pagination controls
	var pages []int
	for i := 1; i <= totalPages; i++ {
		pages = append(pages, i)
	}

	// Calculate display range for "Showing X-Y of Z" message
	showFrom := offset + 1
	showTo := offset + int64(len(solutions))
	if total == 0 {
		showFrom = 0 // Display "Showing 0-0 of 0" for empty results
	}

	return c.Render(http.StatusOK, "admin/pages/solutions_list.html", map[string]interface{}{
		"Title":      "Solutions",
		"Solutions":  solutions,
		"Search":     search,
		"Status":     status,
		"HasFilters": search != "" || status != "",
		"Page":       page,
		"TotalPages": totalPages,
		"Pages":      pages,
		"Total":      total,
		"ShowFrom":   showFrom,
		"ShowTo":     showTo,
	})
}

// New displays the form for creating a new solution.
//
// HTTP Method: GET
// Route: /admin/solutions/new
// Template: admin/pages/solutions_form.html (full page render)
// HTMX: No - returns full page
//
// This handler renders an empty solution creation form. The form submits to
// the Create handler via POST /admin/solutions.
func (h *SolutionsHandler) New(c echo.Context) error {
	return c.Render(http.StatusOK, "admin/pages/solutions_form.html", map[string]interface{}{
		"Title":      "New Solution",
		"FormAction": "/admin/solutions",
		"Item":       nil,
	})
}

// Create handles solution creation.
//
// HTTP Method: POST
// Route: /admin/solutions
// HTMX: No - performs redirect after success
// Template: None - redirects to /admin/solutions on success
//
// Form Fields:
//   - title: Solution title (required)
//   - slug: URL slug (auto-generated from title if empty)
//   - icon: Icon identifier or class name
//   - short_description: Brief summary
//   - hero_image_url: URL to hero section image
//   - hero_title: Hero section title
//   - hero_description: Hero section description
//   - overview_content: Rich text content from Trix editor
//   - meta_description: SEO meta description
//   - reference_code: Internal reference code
//   - is_published: Publication status ("1", "on", or empty)
//   - display_order: Sort order (integer)
//
// Business Logic:
//   - Auto-generates slug from title if not provided using makeSlug()
//   - Converts checkbox/select values to appropriate SQL nullable types
//   - Invalidates "page:solutions" cache entries after creation
//   - Logs activity for audit trail
func (h *SolutionsHandler) Create(c echo.Context) error {
	// Extract basic form values
	title := c.FormValue("title")
	slug := c.FormValue("slug")
	// Auto-generate slug from title if not provided
	if slug == "" {
		slug = makeSlug(title)
	}

	icon := c.FormValue("icon")
	shortDescription := c.FormValue("short_description")
	heroImageUrl := c.FormValue("hero_image_url")
	heroTitle := c.FormValue("hero_title")
	heroDescription := c.FormValue("hero_description")
	overviewContent := c.FormValue("overview_content")       // Rich text from Trix editor
	metaDescription := c.FormValue("meta_description")       // SEO meta tag
	referenceCode := c.FormValue("reference_code")           // Internal reference
	isPublished := c.FormValue("is_published") == "1" || c.FormValue("is_published") == "on" // Checkbox or select

	// Parse display order - defaults to 0 if not provided or invalid
	displayOrder := int64(0)
	if v := c.FormValue("display_order"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			displayOrder = parsed
		}
	}

	// Build database params - using sql.NullString for optional fields
	params := sqlc.CreateSolutionParams{
		Title:            title,
		Slug:             slug,
		Icon:             icon,
		ShortDescription: shortDescription,
		HeroImageUrl:     sql.NullString{String: heroImageUrl, Valid: heroImageUrl != ""},
		HeroTitle:        sql.NullString{String: heroTitle, Valid: heroTitle != ""},
		HeroDescription:  sql.NullString{String: heroDescription, Valid: heroDescription != ""},
		OverviewContent:  sql.NullString{String: overviewContent, Valid: overviewContent != ""},
		MetaDescription:  sql.NullString{String: metaDescription, Valid: metaDescription != ""},
		ReferenceCode:    sql.NullString{String: referenceCode, Valid: referenceCode != ""},
		IsPublished:      sql.NullBool{Bool: isPublished, Valid: true},
		DisplayOrder:     sql.NullInt64{Int64: displayOrder, Valid: true},
	}

	// Execute database insert
	_, err := h.queries.CreateSolution(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to create solution", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to create solution")
	}

	// Invalidate cached solutions pages
	h.cache.DeleteByPrefix("page:solutions")
	// Log the creation for audit trail (uses helper function from common.go)
	logActivity(c, "created", "solution", 0, c.FormValue("title"), "Created Solution '%s'", c.FormValue("title"))
	// Redirect to list view after successful creation
	return c.Redirect(http.StatusSeeOther, "/admin/solutions")
}

// Edit displays the form for editing a solution.
//
// HTTP Method: GET
// Route: /admin/solutions/:id/edit
// Template: admin/pages/solutions_form.html (full page render)
// HTMX: No - returns full page
//
// Route Parameters:
//   - id: Solution ID (int64)
//
// This handler loads an existing solution and all its related resources:
//   - Solution basic data
//   - Stats (key metrics displayed on solution page)
//   - Challenges (problems the solution addresses)
//   - Products (linked product offerings)
//   - CTAs (call-to-action sections)
//
// The form submits to the Update handler via POST /admin/solutions/:id.
func (h *SolutionsHandler) Edit(c echo.Context) error {
	// Parse and validate solution ID from route parameter
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	// Load solution base data
	solution, err := h.queries.GetSolutionByID(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get solution", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load solution")
	}

	// Load related stats (graceful degradation on error - show empty array)
	stats, err := h.queries.GetSolutionStats(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get solution stats", "error", err)
		stats = []sqlc.SolutionStat{}
	}

	// Load related challenges (graceful degradation on error)
	challenges, err := h.queries.GetSolutionChallenges(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get solution challenges", "error", err)
		challenges = []sqlc.SolutionChallenge{}
	}

	// Load linked products with join data (graceful degradation on error)
	products, err := h.queries.GetSolutionProducts(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get solution products", "error", err)
		products = []sqlc.GetSolutionProductsRow{}
	}

	// Load CTAs (call-to-action sections) - graceful degradation on error
	ctas, err := h.queries.GetSolutionCTAs(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to get solution CTAs", "error", err)
		ctas = []sqlc.SolutionCta{}
	}

	return c.Render(http.StatusOK, "admin/pages/solutions_form.html", map[string]interface{}{
		"Title":      "Edit Solution",
		"FormAction": "/admin/solutions/" + c.Param("id"),
		"Item":       solution,
		"Stats":      stats,
		"Challenges": challenges,
		"Products":   products,
		"CTAs":       ctas,
	})
}

// Update handles solution updates.
//
// HTTP Method: POST
// Route: /admin/solutions/:id
// HTMX: No - performs redirect after success
// Template: None - redirects to /admin/solutions on success
//
// Route Parameters:
//   - id: Solution ID (int64)
//
// Form Fields: Same as Create handler (see Create documentation)
//
// Business Logic:
//   - Updates only the solution base record (not related resources)
//   - Related resources (stats, challenges, products, CTAs) updated via separate endpoints
//   - Auto-generates slug from title if not provided
//   - Invalidates "page:solutions" cache entries
//   - Logs activity for audit trail
func (h *SolutionsHandler) Update(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	title := c.FormValue("title")
	slug := c.FormValue("slug")
	if slug == "" {
		slug = makeSlug(title)
	}

	icon := c.FormValue("icon")
	shortDescription := c.FormValue("short_description")
	heroImageUrl := c.FormValue("hero_image_url")
	heroTitle := c.FormValue("hero_title")
	heroDescription := c.FormValue("hero_description")
	overviewContent := c.FormValue("overview_content")
	metaDescription := c.FormValue("meta_description")
	referenceCode := c.FormValue("reference_code")
	isPublished := c.FormValue("is_published") == "1" || c.FormValue("is_published") == "on"

	displayOrder := int64(0)
	if v := c.FormValue("display_order"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			displayOrder = parsed
		}
	}

	params := sqlc.UpdateSolutionParams{
		ID:               id,
		Title:            title,
		Slug:             slug,
		Icon:             icon,
		ShortDescription: shortDescription,
		HeroImageUrl:     sql.NullString{String: heroImageUrl, Valid: heroImageUrl != ""},
		HeroTitle:        sql.NullString{String: heroTitle, Valid: heroTitle != ""},
		HeroDescription:  sql.NullString{String: heroDescription, Valid: heroDescription != ""},
		OverviewContent:  sql.NullString{String: overviewContent, Valid: overviewContent != ""},
		MetaDescription:  sql.NullString{String: metaDescription, Valid: metaDescription != ""},
		ReferenceCode:    sql.NullString{String: referenceCode, Valid: referenceCode != ""},
		IsPublished:      sql.NullBool{Bool: isPublished, Valid: true},
		DisplayOrder:     sql.NullInt64{Int64: displayOrder, Valid: true},
	}

	err = h.queries.UpdateSolution(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to update solution", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to update solution")
	}

	h.cache.DeleteByPrefix("page:solutions")
	logActivity(c, "updated", "solution", id, c.FormValue("title"), "Updated Solution '%s'", c.FormValue("title"))
	return c.Redirect(http.StatusSeeOther, "/admin/solutions")
}

// Delete handles solution deletion.
//
// HTTP Method: DELETE
// Route: /admin/solutions/:id
// HTMX: Yes - triggered by hx-delete on delete button
// Template: None - returns HTTP 204 No Content
//
// Route Parameters:
//   - id: Solution ID (int64)
//
// Business Logic:
//   - Deletes solution and all related resources (cascade delete handled by DB)
//   - Invalidates "page:solutions" cache entries
//   - Logs activity for audit trail
//   - Returns 204 No Content on success (HTMX removes element from DOM)
func (h *SolutionsHandler) Delete(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	err = h.queries.DeleteSolution(c.Request().Context(), id)
	if err != nil {
		h.logger.Error("Failed to delete solution", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to delete solution")
	}

	h.cache.DeleteByPrefix("page:solutions")
	logActivity(c, "deleted", "solution", id, "", "Deleted Solution #%d", id)
	return c.NoContent(http.StatusNoContent)
}

// AddStat adds a stat to a solution.
//
// HTTP Method: POST
// Route: /admin/solutions/:id/stats
// HTMX: Yes - returns HTML fragment for DOM swap
// Template: admin/partials/solution_stats.html (partial render)
//
// Route Parameters:
//   - id: Solution ID (int64)
//
// Form Fields:
//   - value: Stat value (e.g., "99%", "10K+")
//   - label: Stat description (e.g., "Customer Satisfaction")
//   - display_order: Sort order (integer, optional)
//
// HTMX Behavior:
//   - Returns updated stats list partial after insertion
//   - HTMX swaps entire stats container with new content
//   - Allows immediate visual feedback without page reload
func (h *SolutionsHandler) AddStat(c echo.Context) error {
	solutionID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	value := c.FormValue("value")
	label := c.FormValue("label")

	displayOrder := int64(0)
	if v := c.FormValue("display_order"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			displayOrder = parsed
		}
	}

	params := sqlc.CreateSolutionStatParams{
		SolutionID:   solutionID,
		Value:        value,
		Label:        label,
		DisplayOrder: sql.NullInt64{Int64: displayOrder, Valid: true},
	}

	_, err = h.queries.CreateSolutionStat(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to create solution stat", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to add stat")
	}

	h.cache.DeleteByPrefix("page:solutions")

	stats, err := h.queries.GetSolutionStats(c.Request().Context(), solutionID)
	if err != nil {
		h.logger.Error("Failed to get solution stats", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load stats")
	}

	logActivity(c, "updated", "solution", solutionID, "", "Updated Solution #%d sub-resources", solutionID)
	return c.Render(http.StatusOK, "admin/partials/solution_stats.html", map[string]interface{}{
		"Stats": stats,
	})
}

// DeleteStat deletes a stat from a solution.
//
// HTTP Method: DELETE
// Route: /admin/solutions/:id/stats/:statId
// HTMX: Yes - triggered by hx-delete on delete button
// Template: None - returns HTTP 200 OK (not 204 for HTMX compatibility)
//
// Route Parameters:
//   - statId: Stat ID (int64) - note: :id not used, statId identifies the resource
//
// HTMX Behavior:
//   - Returns 200 OK to trigger hx-target removal
//   - HTMX removes the stat element from DOM
func (h *SolutionsHandler) DeleteStat(c echo.Context) error {
	statID, err := strconv.ParseInt(c.Param("statId"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid stat ID")
	}

	err = h.queries.DeleteSolutionStat(c.Request().Context(), statID)
	if err != nil {
		h.logger.Error("Failed to delete solution stat", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to delete stat")
	}

	h.cache.DeleteByPrefix("page:solutions")
	// Note: solutionID not available in DeleteStat, use statID as reference
	logActivity(c, "updated", "solution", statID, "", "Updated Solution #%d sub-resources", statID)
	return c.NoContent(http.StatusOK)
}

// AddChallenge adds a challenge to a solution.
//
// HTTP Method: POST
// Route: /admin/solutions/:id/challenges
// HTMX: Yes - returns HTML fragment for DOM swap
// Template: admin/partials/solution_challenges.html (partial render)
//
// Route Parameters:
//   - id: Solution ID (int64)
//
// Form Fields:
//   - title: Challenge title
//   - description: Challenge description
//   - icon: Icon identifier or class name
//   - display_order: Sort order (integer, optional)
//
// HTMX Behavior:
//   - Returns updated challenges list partial after insertion
//   - HTMX swaps entire challenges container with new content
func (h *SolutionsHandler) AddChallenge(c echo.Context) error {
	solutionID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	title := c.FormValue("title")
	description := c.FormValue("description")
	icon := c.FormValue("icon")

	displayOrder := int64(0)
	if v := c.FormValue("display_order"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			displayOrder = parsed
		}
	}

	params := sqlc.CreateSolutionChallengeParams{
		SolutionID:   solutionID,
		Title:        title,
		Description:  description,
		Icon:         icon,
		DisplayOrder: sql.NullInt64{Int64: displayOrder, Valid: true},
	}

	_, err = h.queries.CreateSolutionChallenge(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to create solution challenge", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to add challenge")
	}

	h.cache.DeleteByPrefix("page:solutions")

	challenges, err := h.queries.GetSolutionChallenges(c.Request().Context(), solutionID)
	if err != nil {
		h.logger.Error("Failed to get solution challenges", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load challenges")
	}

	logActivity(c, "updated", "solution", solutionID, "", "Updated Solution #%d sub-resources", solutionID)
	return c.Render(http.StatusOK, "admin/partials/solution_challenges.html", map[string]interface{}{
		"Challenges": challenges,
	})
}

// DeleteChallenge deletes a challenge from a solution.
//
// HTTP Method: DELETE
// Route: /admin/solutions/:id/challenges/:challengeId
// HTMX: Yes - triggered by hx-delete on delete button
// Template: None - returns HTTP 200 OK
//
// Route Parameters:
//   - challengeId: Challenge ID (int64)
//
// HTMX Behavior:
//   - Returns 200 OK to trigger hx-target removal
//   - HTMX removes the challenge element from DOM
func (h *SolutionsHandler) DeleteChallenge(c echo.Context) error {
	challengeID, err := strconv.ParseInt(c.Param("challengeId"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid challenge ID")
	}

	err = h.queries.DeleteSolutionChallenge(c.Request().Context(), challengeID)
	if err != nil {
		h.logger.Error("Failed to delete solution challenge", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to delete challenge")
	}

	h.cache.DeleteByPrefix("page:solutions")
	// Note: solutionID not available in DeleteChallenge, use challengeID as reference
	logActivity(c, "updated", "solution", challengeID, "", "Updated Solution #%d sub-resources", challengeID)
	return c.NoContent(http.StatusOK)
}

// AddProduct links a product to a solution.
//
// HTTP Method: POST
// Route: /admin/solutions/:id/products
// HTMX: Yes - returns HTML fragment for DOM swap
// Template: admin/partials/solution_products.html (partial render)
//
// Route Parameters:
//   - id: Solution ID (int64)
//
// Form Fields:
//   - product_id: Product ID to link (int64, required)
//   - display_order: Sort order (integer, optional)
//   - is_featured: Whether product is featured on solution page ("1" or empty)
//
// Business Logic:
//   - Creates many-to-many relationship in solution_products table
//   - Product must exist in products table (foreign key constraint)
//
// HTMX Behavior:
//   - Returns updated products list partial after insertion
//   - HTMX swaps entire products container with new content
func (h *SolutionsHandler) AddProduct(c echo.Context) error {
	solutionID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	productID, err := strconv.ParseInt(c.FormValue("product_id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid product ID")
	}

	displayOrder := int64(0)
	if v := c.FormValue("display_order"); v != "" {
		if parsed, err := strconv.ParseInt(v, 10, 64); err == nil {
			displayOrder = parsed
		}
	}

	isFeatured := c.FormValue("is_featured") == "1"

	params := sqlc.AddProductToSolutionParams{
		SolutionID:   solutionID,
		ProductID:    productID,
		DisplayOrder: sql.NullInt64{Int64: displayOrder, Valid: true},
		IsFeatured:   sql.NullBool{Bool: isFeatured, Valid: true},
	}

	err = h.queries.AddProductToSolution(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to add product to solution", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to add product")
	}

	h.cache.DeleteByPrefix("page:solutions")

	products, err := h.queries.GetSolutionProducts(c.Request().Context(), solutionID)
	if err != nil {
		h.logger.Error("Failed to get solution products", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load products")
	}

	logActivity(c, "updated", "solution", solutionID, "", "Updated Solution #%d sub-resources", solutionID)
	return c.Render(http.StatusOK, "admin/partials/solution_products.html", map[string]interface{}{
		"Products": products,
	})
}

// RemoveProduct removes a product from a solution.
//
// HTTP Method: DELETE
// Route: /admin/solutions/:id/products/:productId
// HTMX: Yes - triggered by hx-delete on delete button
// Template: None - returns HTTP 200 OK
//
// Route Parameters:
//   - id: Solution ID (int64)
//   - productId: Product ID (int64)
//
// Business Logic:
//   - Deletes from solution_products junction table
//   - Does not delete the product itself, only the relationship
//
// HTMX Behavior:
//   - Returns 200 OK to trigger hx-target removal
//   - HTMX removes the product element from DOM
func (h *SolutionsHandler) RemoveProduct(c echo.Context) error {
	solutionID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	productID, err := strconv.ParseInt(c.Param("productId"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid product ID")
	}

	params := sqlc.RemoveProductFromSolutionParams{
		SolutionID: solutionID,
		ProductID:  productID,
	}

	err = h.queries.RemoveProductFromSolution(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to remove product from solution", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to remove product")
	}

	h.cache.DeleteByPrefix("page:solutions")
	logActivity(c, "updated", "solution", solutionID, "", "Updated Solution #%d sub-resources", solutionID)
	return c.NoContent(http.StatusOK)
}

// AddCTA adds a CTA (call-to-action) section to a solution.
//
// HTTP Method: POST
// Route: /admin/solutions/:id/ctas
// HTMX: Yes - returns HTML fragment for DOM swap
// Template: admin/partials/solution_ctas.html (partial render)
//
// Route Parameters:
//   - id: Solution ID (int64)
//
// Form Fields:
//   - heading: CTA heading text (required)
//   - subheading: CTA subheading text (optional)
//   - primary_button_text: Text for primary action button (optional)
//   - primary_button_url: URL for primary button (optional)
//   - secondary_button_text: Text for secondary action button (optional)
//   - secondary_button_url: URL for secondary button (optional)
//   - phone_number: Contact phone number to display (optional)
//   - section_name: Internal identifier for CTA placement (e.g., "hero", "footer")
//
// Business Logic:
//   - CTAs are contextual action prompts displayed on solution pages
//   - Multiple CTAs can exist per solution in different sections
//
// HTMX Behavior:
//   - Returns updated CTAs list partial after insertion
//   - HTMX swaps entire CTAs container with new content
func (h *SolutionsHandler) AddCTA(c echo.Context) error {
	solutionID, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid solution ID")
	}

	heading := c.FormValue("heading")
	subheading := c.FormValue("subheading")
	primaryButtonText := c.FormValue("primary_button_text")
	primaryButtonUrl := c.FormValue("primary_button_url")
	secondaryButtonText := c.FormValue("secondary_button_text")
	secondaryButtonUrl := c.FormValue("secondary_button_url")
	phoneNumber := c.FormValue("phone_number")
	sectionName := c.FormValue("section_name")

	params := sqlc.CreateSolutionCTAParams{
		SolutionID:          solutionID,
		Heading:             heading,
		Subheading:          sql.NullString{String: subheading, Valid: subheading != ""},
		PrimaryButtonText:   sql.NullString{String: primaryButtonText, Valid: primaryButtonText != ""},
		PrimaryButtonUrl:    sql.NullString{String: primaryButtonUrl, Valid: primaryButtonUrl != ""},
		SecondaryButtonText: sql.NullString{String: secondaryButtonText, Valid: secondaryButtonText != ""},
		SecondaryButtonUrl:  sql.NullString{String: secondaryButtonUrl, Valid: secondaryButtonUrl != ""},
		PhoneNumber:         sql.NullString{String: phoneNumber, Valid: phoneNumber != ""},
		SectionName:         sectionName,
	}

	_, err = h.queries.CreateSolutionCTA(c.Request().Context(), params)
	if err != nil {
		h.logger.Error("Failed to create solution CTA", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to add CTA")
	}

	h.cache.DeleteByPrefix("page:solutions")

	ctas, err := h.queries.GetSolutionCTAs(c.Request().Context(), solutionID)
	if err != nil {
		h.logger.Error("Failed to get solution CTAs", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to load CTAs")
	}

	logActivity(c, "updated", "solution", solutionID, "", "Updated Solution #%d sub-resources", solutionID)
	return c.Render(http.StatusOK, "admin/partials/solution_ctas.html", map[string]interface{}{
		"CTAs": ctas,
	})
}

// DeleteCTA deletes a CTA from a solution.
//
// HTTP Method: DELETE
// Route: /admin/solutions/:id/ctas/:ctaId
// HTMX: Yes - triggered by hx-delete on delete button
// Template: None - returns HTTP 200 OK
//
// Route Parameters:
//   - ctaId: CTA ID (int64)
//
// HTMX Behavior:
//   - Returns 200 OK to trigger hx-target removal
//   - HTMX removes the CTA element from DOM
func (h *SolutionsHandler) DeleteCTA(c echo.Context) error {
	ctaID, err := strconv.ParseInt(c.Param("ctaId"), 10, 64)
	if err != nil {
		return c.String(http.StatusBadRequest, "Invalid CTA ID")
	}

	err = h.queries.DeleteSolutionCTA(c.Request().Context(), ctaID)
	if err != nil {
		h.logger.Error("Failed to delete solution CTA", "error", err)
		return c.String(http.StatusInternalServerError, "Failed to delete CTA")
	}

	h.cache.DeleteByPrefix("page:solutions")
	// Note: solutionID not available in DeleteCTA, use ctaID as reference
	logActivity(c, "updated", "solution", ctaID, "", "Updated Solution #%d sub-resources", ctaID)
	return c.NoContent(http.StatusOK)
}
