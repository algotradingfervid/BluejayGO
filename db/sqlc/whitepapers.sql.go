// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: whitepapers.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countPublishedWhitepapers = `-- name: CountPublishedWhitepapers :one
SELECT COUNT(*) FROM whitepapers WHERE is_published = 1
`

func (q *Queries) CountPublishedWhitepapers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedWhitepapers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedWhitepapersByTopic = `-- name: CountPublishedWhitepapersByTopic :one
SELECT COUNT(*) FROM whitepapers WHERE is_published = 1 AND topic_id = ?
`

func (q *Queries) CountPublishedWhitepapersByTopic(ctx context.Context, topicID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedWhitepapersByTopic, topicID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWhitepaperDownloads = `-- name: CountWhitepaperDownloads :one
SELECT COUNT(*) FROM whitepaper_downloads
`

func (q *Queries) CountWhitepaperDownloads(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWhitepaperDownloads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWhitepaperDownloadsFiltered = `-- name: CountWhitepaperDownloadsFiltered :one
SELECT COUNT(*) FROM whitepaper_downloads wd
WHERE
    (CASE WHEN ?1 = 0 THEN 1 ELSE wd.whitepaper_id = ?1 END)
    AND (CASE WHEN ?2 = '' THEN 1 ELSE wd.created_at >= ?2 END)
    AND (CASE WHEN ?3 = '' THEN 1 ELSE wd.created_at <= ?3 || ' 23:59:59' END)
`

type CountWhitepaperDownloadsFilteredParams struct {
	FilterWhitepaper interface{} `json:"filter_whitepaper"`
	FilterDateFrom   interface{} `json:"filter_date_from"`
	FilterDateTo     interface{} `json:"filter_date_to"`
}

func (q *Queries) CountWhitepaperDownloadsFiltered(ctx context.Context, arg CountWhitepaperDownloadsFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWhitepaperDownloadsFiltered, arg.FilterWhitepaper, arg.FilterDateFrom, arg.FilterDateTo)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWhitepapersAdminFiltered = `-- name: CountWhitepapersAdminFiltered :one
SELECT COUNT(*) FROM whitepapers w
WHERE
    (CASE WHEN ?1 = '' THEN 1 ELSE w.title LIKE '%' || ?1 || '%' END)
    AND (CASE WHEN ?2 = 0 THEN 1 ELSE w.topic_id = ?2 END)
    AND (CASE WHEN ?3 = '' THEN 1
         WHEN ?3 = 'published' THEN w.is_published = 1
         WHEN ?3 = 'draft' THEN w.is_published = 0
         ELSE 1 END)
`

type CountWhitepapersAdminFilteredParams struct {
	FilterSearch interface{} `json:"filter_search"`
	FilterTopic  interface{} `json:"filter_topic"`
	FilterStatus interface{} `json:"filter_status"`
}

func (q *Queries) CountWhitepapersAdminFiltered(ctx context.Context, arg CountWhitepapersAdminFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWhitepapersAdminFiltered, arg.FilterSearch, arg.FilterTopic, arg.FilterStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWhitepaper = `-- name: CreateWhitepaper :one
INSERT INTO whitepapers (
    title, slug, description, topic_id, pdf_file_path, file_size_bytes, page_count,
    published_date, is_published, cover_color_from, cover_color_to, meta_description
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, slug, description, topic_id, pdf_file_path, file_size_bytes, page_count, published_date, is_published, cover_color_from, cover_color_to, meta_description, download_count, created_at, updated_at, meta_title, og_image
`

type CreateWhitepaperParams struct {
	Title           string         `json:"title"`
	Slug            string         `json:"slug"`
	Description     string         `json:"description"`
	TopicID         int64          `json:"topic_id"`
	PdfFilePath     string         `json:"pdf_file_path"`
	FileSizeBytes   int64          `json:"file_size_bytes"`
	PageCount       sql.NullInt64  `json:"page_count"`
	PublishedDate   string         `json:"published_date"`
	IsPublished     int64          `json:"is_published"`
	CoverColorFrom  string         `json:"cover_color_from"`
	CoverColorTo    string         `json:"cover_color_to"`
	MetaDescription sql.NullString `json:"meta_description"`
}

func (q *Queries) CreateWhitepaper(ctx context.Context, arg CreateWhitepaperParams) (Whitepaper, error) {
	row := q.db.QueryRowContext(ctx, createWhitepaper,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.TopicID,
		arg.PdfFilePath,
		arg.FileSizeBytes,
		arg.PageCount,
		arg.PublishedDate,
		arg.IsPublished,
		arg.CoverColorFrom,
		arg.CoverColorTo,
		arg.MetaDescription,
	)
	var i Whitepaper
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.TopicID,
		&i.PdfFilePath,
		&i.FileSizeBytes,
		&i.PageCount,
		&i.PublishedDate,
		&i.IsPublished,
		&i.CoverColorFrom,
		&i.CoverColorTo,
		&i.MetaDescription,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MetaTitle,
		&i.OgImage,
	)
	return i, err
}

const createWhitepaperDownload = `-- name: CreateWhitepaperDownload :one
INSERT INTO whitepaper_downloads (
    whitepaper_id, name, email, company, designation, marketing_consent, ip_address, user_agent
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, created_at
`

type CreateWhitepaperDownloadParams struct {
	WhitepaperID     int64          `json:"whitepaper_id"`
	Name             string         `json:"name"`
	Email            string         `json:"email"`
	Company          string         `json:"company"`
	Designation      sql.NullString `json:"designation"`
	MarketingConsent int64          `json:"marketing_consent"`
	IpAddress        sql.NullString `json:"ip_address"`
	UserAgent        sql.NullString `json:"user_agent"`
}

type CreateWhitepaperDownloadRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateWhitepaperDownload(ctx context.Context, arg CreateWhitepaperDownloadParams) (CreateWhitepaperDownloadRow, error) {
	row := q.db.QueryRowContext(ctx, createWhitepaperDownload,
		arg.WhitepaperID,
		arg.Name,
		arg.Email,
		arg.Company,
		arg.Designation,
		arg.MarketingConsent,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i CreateWhitepaperDownloadRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createWhitepaperLearningPoint = `-- name: CreateWhitepaperLearningPoint :one
INSERT INTO whitepaper_learning_points (whitepaper_id, point_text, display_order)
VALUES (?, ?, ?)
RETURNING id
`

type CreateWhitepaperLearningPointParams struct {
	WhitepaperID int64  `json:"whitepaper_id"`
	PointText    string `json:"point_text"`
	DisplayOrder int64  `json:"display_order"`
}

func (q *Queries) CreateWhitepaperLearningPoint(ctx context.Context, arg CreateWhitepaperLearningPointParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createWhitepaperLearningPoint, arg.WhitepaperID, arg.PointText, arg.DisplayOrder)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteWhitepaper = `-- name: DeleteWhitepaper :exec
DELETE FROM whitepapers WHERE id = ?
`

func (q *Queries) DeleteWhitepaper(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteWhitepaper, id)
	return err
}

const deleteWhitepaperLearningPoints = `-- name: DeleteWhitepaperLearningPoints :exec
DELETE FROM whitepaper_learning_points WHERE whitepaper_id = ?
`

func (q *Queries) DeleteWhitepaperLearningPoints(ctx context.Context, whitepaperID int64) error {
	_, err := q.db.ExecContext(ctx, deleteWhitepaperLearningPoints, whitepaperID)
	return err
}

const getRelatedWhitepapers = `-- name: GetRelatedWhitepapers :many
SELECT
    w.id, w.title, w.slug, w.cover_color_from, w.cover_color_to
FROM whitepapers w
WHERE w.is_published = 1
  AND w.id != ?
  AND w.topic_id = ?
ORDER BY w.published_date DESC
LIMIT 3
`

type GetRelatedWhitepapersParams struct {
	ID      int64 `json:"id"`
	TopicID int64 `json:"topic_id"`
}

type GetRelatedWhitepapersRow struct {
	ID             int64  `json:"id"`
	Title          string `json:"title"`
	Slug           string `json:"slug"`
	CoverColorFrom string `json:"cover_color_from"`
	CoverColorTo   string `json:"cover_color_to"`
}

func (q *Queries) GetRelatedWhitepapers(ctx context.Context, arg GetRelatedWhitepapersParams) ([]GetRelatedWhitepapersRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedWhitepapers, arg.ID, arg.TopicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelatedWhitepapersRow{}
	for rows.Next() {
		var i GetRelatedWhitepapersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.CoverColorFrom,
			&i.CoverColorTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWhitepaperByID = `-- name: GetWhitepaperByID :one
SELECT
    w.id, w.title, w.slug, w.description, w.topic_id, w.pdf_file_path, w.file_size_bytes,
    w.page_count, w.published_date, w.is_published, w.cover_color_from, w.cover_color_to,
    w.meta_description, w.download_count, w.created_at, w.updated_at
FROM whitepapers w
WHERE w.id = ?
`

type GetWhitepaperByIDRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Slug            string         `json:"slug"`
	Description     string         `json:"description"`
	TopicID         int64          `json:"topic_id"`
	PdfFilePath     string         `json:"pdf_file_path"`
	FileSizeBytes   int64          `json:"file_size_bytes"`
	PageCount       sql.NullInt64  `json:"page_count"`
	PublishedDate   string         `json:"published_date"`
	IsPublished     int64          `json:"is_published"`
	CoverColorFrom  string         `json:"cover_color_from"`
	CoverColorTo    string         `json:"cover_color_to"`
	MetaDescription sql.NullString `json:"meta_description"`
	DownloadCount   int64          `json:"download_count"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
}

func (q *Queries) GetWhitepaperByID(ctx context.Context, id int64) (GetWhitepaperByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getWhitepaperByID, id)
	var i GetWhitepaperByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.TopicID,
		&i.PdfFilePath,
		&i.FileSizeBytes,
		&i.PageCount,
		&i.PublishedDate,
		&i.IsPublished,
		&i.CoverColorFrom,
		&i.CoverColorTo,
		&i.MetaDescription,
		&i.DownloadCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWhitepaperBySlug = `-- name: GetWhitepaperBySlug :one
SELECT
    w.id, w.title, w.slug, w.description, w.topic_id, w.pdf_file_path, w.file_size_bytes,
    w.page_count, w.published_date, w.cover_color_from, w.cover_color_to, w.download_count,
    w.meta_description, w.meta_title, w.og_image,
    t.name as topic_name, t.color_hex as topic_color_hex
FROM whitepapers w
INNER JOIN whitepaper_topics t ON w.topic_id = t.id
WHERE w.slug = ? AND w.is_published = 1
`

type GetWhitepaperBySlugRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Slug            string         `json:"slug"`
	Description     string         `json:"description"`
	TopicID         int64          `json:"topic_id"`
	PdfFilePath     string         `json:"pdf_file_path"`
	FileSizeBytes   int64          `json:"file_size_bytes"`
	PageCount       sql.NullInt64  `json:"page_count"`
	PublishedDate   string         `json:"published_date"`
	CoverColorFrom  string         `json:"cover_color_from"`
	CoverColorTo    string         `json:"cover_color_to"`
	DownloadCount   int64          `json:"download_count"`
	MetaDescription sql.NullString `json:"meta_description"`
	MetaTitle       string         `json:"meta_title"`
	OgImage         string         `json:"og_image"`
	TopicName       string         `json:"topic_name"`
	TopicColorHex   string         `json:"topic_color_hex"`
}

func (q *Queries) GetWhitepaperBySlug(ctx context.Context, slug string) (GetWhitepaperBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getWhitepaperBySlug, slug)
	var i GetWhitepaperBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.TopicID,
		&i.PdfFilePath,
		&i.FileSizeBytes,
		&i.PageCount,
		&i.PublishedDate,
		&i.CoverColorFrom,
		&i.CoverColorTo,
		&i.DownloadCount,
		&i.MetaDescription,
		&i.MetaTitle,
		&i.OgImage,
		&i.TopicName,
		&i.TopicColorHex,
	)
	return i, err
}

const getWhitepaperBySlugIncludeDrafts = `-- name: GetWhitepaperBySlugIncludeDrafts :one
SELECT
    w.id, w.title, w.slug, w.description, w.topic_id, w.pdf_file_path, w.file_size_bytes,
    w.page_count, w.published_date, w.cover_color_from, w.cover_color_to, w.download_count,
    w.meta_description, w.meta_title, w.og_image,
    t.name as topic_name, t.color_hex as topic_color_hex
FROM whitepapers w
INNER JOIN whitepaper_topics t ON w.topic_id = t.id
WHERE w.slug = ?
`

type GetWhitepaperBySlugIncludeDraftsRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Slug            string         `json:"slug"`
	Description     string         `json:"description"`
	TopicID         int64          `json:"topic_id"`
	PdfFilePath     string         `json:"pdf_file_path"`
	FileSizeBytes   int64          `json:"file_size_bytes"`
	PageCount       sql.NullInt64  `json:"page_count"`
	PublishedDate   string         `json:"published_date"`
	CoverColorFrom  string         `json:"cover_color_from"`
	CoverColorTo    string         `json:"cover_color_to"`
	DownloadCount   int64          `json:"download_count"`
	MetaDescription sql.NullString `json:"meta_description"`
	MetaTitle       string         `json:"meta_title"`
	OgImage         string         `json:"og_image"`
	TopicName       string         `json:"topic_name"`
	TopicColorHex   string         `json:"topic_color_hex"`
}

func (q *Queries) GetWhitepaperBySlugIncludeDrafts(ctx context.Context, slug string) (GetWhitepaperBySlugIncludeDraftsRow, error) {
	row := q.db.QueryRowContext(ctx, getWhitepaperBySlugIncludeDrafts, slug)
	var i GetWhitepaperBySlugIncludeDraftsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.TopicID,
		&i.PdfFilePath,
		&i.FileSizeBytes,
		&i.PageCount,
		&i.PublishedDate,
		&i.CoverColorFrom,
		&i.CoverColorTo,
		&i.DownloadCount,
		&i.MetaDescription,
		&i.MetaTitle,
		&i.OgImage,
		&i.TopicName,
		&i.TopicColorHex,
	)
	return i, err
}

const getWhitepaperLearningPoints = `-- name: GetWhitepaperLearningPoints :many
SELECT id, point_text, display_order
FROM whitepaper_learning_points
WHERE whitepaper_id = ?
ORDER BY display_order ASC, id ASC
`

type GetWhitepaperLearningPointsRow struct {
	ID           int64  `json:"id"`
	PointText    string `json:"point_text"`
	DisplayOrder int64  `json:"display_order"`
}

func (q *Queries) GetWhitepaperLearningPoints(ctx context.Context, whitepaperID int64) ([]GetWhitepaperLearningPointsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWhitepaperLearningPoints, whitepaperID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWhitepaperLearningPointsRow{}
	for rows.Next() {
		var i GetWhitepaperLearningPointsRow
		if err := rows.Scan(&i.ID, &i.PointText, &i.DisplayOrder); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementWhitepaperDownloadCount = `-- name: IncrementWhitepaperDownloadCount :exec
UPDATE whitepapers
SET download_count = download_count + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) IncrementWhitepaperDownloadCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementWhitepaperDownloadCount, id)
	return err
}

const listAllWhitepapers = `-- name: ListAllWhitepapers :many

SELECT
    w.id, w.title, w.slug, w.topic_id, w.is_published, w.published_date, w.download_count,
    w.created_at, w.updated_at,
    t.name as topic_name
FROM whitepapers w
INNER JOIN whitepaper_topics t ON w.topic_id = t.id
ORDER BY w.created_at DESC
`

type ListAllWhitepapersRow struct {
	ID            int64     `json:"id"`
	Title         string    `json:"title"`
	Slug          string    `json:"slug"`
	TopicID       int64     `json:"topic_id"`
	IsPublished   int64     `json:"is_published"`
	PublishedDate string    `json:"published_date"`
	DownloadCount int64     `json:"download_count"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	TopicName     string    `json:"topic_name"`
}

// ====================================================================
// WHITEPAPERS - ADMIN
// ====================================================================
func (q *Queries) ListAllWhitepapers(ctx context.Context) ([]ListAllWhitepapersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllWhitepapers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllWhitepapersRow{}
	for rows.Next() {
		var i ListAllWhitepapersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.TopicID,
			&i.IsPublished,
			&i.PublishedDate,
			&i.DownloadCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TopicName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedWhitepapers = `-- name: ListPublishedWhitepapers :many

SELECT
    w.id, w.title, w.slug, w.description, w.topic_id, w.file_size_bytes, w.page_count,
    w.published_date, w.cover_color_from, w.cover_color_to, w.download_count,
    t.name as topic_name, t.color_hex as topic_color_hex
FROM whitepapers w
INNER JOIN whitepaper_topics t ON w.topic_id = t.id
WHERE w.is_published = 1
ORDER BY w.published_date DESC, w.id DESC
`

type ListPublishedWhitepapersRow struct {
	ID             int64         `json:"id"`
	Title          string        `json:"title"`
	Slug           string        `json:"slug"`
	Description    string        `json:"description"`
	TopicID        int64         `json:"topic_id"`
	FileSizeBytes  int64         `json:"file_size_bytes"`
	PageCount      sql.NullInt64 `json:"page_count"`
	PublishedDate  string        `json:"published_date"`
	CoverColorFrom string        `json:"cover_color_from"`
	CoverColorTo   string        `json:"cover_color_to"`
	DownloadCount  int64         `json:"download_count"`
	TopicName      string        `json:"topic_name"`
	TopicColorHex  string        `json:"topic_color_hex"`
}

// ====================================================================
// WHITEPAPERS
// ====================================================================
func (q *Queries) ListPublishedWhitepapers(ctx context.Context) ([]ListPublishedWhitepapersRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedWhitepapers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedWhitepapersRow{}
	for rows.Next() {
		var i ListPublishedWhitepapersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.TopicID,
			&i.FileSizeBytes,
			&i.PageCount,
			&i.PublishedDate,
			&i.CoverColorFrom,
			&i.CoverColorTo,
			&i.DownloadCount,
			&i.TopicName,
			&i.TopicColorHex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedWhitepapersByTopic = `-- name: ListPublishedWhitepapersByTopic :many
SELECT
    w.id, w.title, w.slug, w.description, w.topic_id, w.file_size_bytes, w.page_count,
    w.published_date, w.cover_color_from, w.cover_color_to, w.download_count,
    t.name as topic_name, t.color_hex as topic_color_hex
FROM whitepapers w
INNER JOIN whitepaper_topics t ON w.topic_id = t.id
WHERE w.is_published = 1 AND w.topic_id = ?
ORDER BY w.published_date DESC, w.id DESC
`

type ListPublishedWhitepapersByTopicRow struct {
	ID             int64         `json:"id"`
	Title          string        `json:"title"`
	Slug           string        `json:"slug"`
	Description    string        `json:"description"`
	TopicID        int64         `json:"topic_id"`
	FileSizeBytes  int64         `json:"file_size_bytes"`
	PageCount      sql.NullInt64 `json:"page_count"`
	PublishedDate  string        `json:"published_date"`
	CoverColorFrom string        `json:"cover_color_from"`
	CoverColorTo   string        `json:"cover_color_to"`
	DownloadCount  int64         `json:"download_count"`
	TopicName      string        `json:"topic_name"`
	TopicColorHex  string        `json:"topic_color_hex"`
}

func (q *Queries) ListPublishedWhitepapersByTopic(ctx context.Context, topicID int64) ([]ListPublishedWhitepapersByTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedWhitepapersByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedWhitepapersByTopicRow{}
	for rows.Next() {
		var i ListPublishedWhitepapersByTopicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.TopicID,
			&i.FileSizeBytes,
			&i.PageCount,
			&i.PublishedDate,
			&i.CoverColorFrom,
			&i.CoverColorTo,
			&i.DownloadCount,
			&i.TopicName,
			&i.TopicColorHex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWhitepaperDownloads = `-- name: ListWhitepaperDownloads :many
SELECT
    wd.id, wd.whitepaper_id, wd.name, wd.email, wd.company, wd.designation,
    wd.marketing_consent, wd.created_at,
    w.title as whitepaper_title
FROM whitepaper_downloads wd
INNER JOIN whitepapers w ON wd.whitepaper_id = w.id
ORDER BY wd.created_at DESC
LIMIT ? OFFSET ?
`

type ListWhitepaperDownloadsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListWhitepaperDownloadsRow struct {
	ID               int64          `json:"id"`
	WhitepaperID     int64          `json:"whitepaper_id"`
	Name             string         `json:"name"`
	Email            string         `json:"email"`
	Company          string         `json:"company"`
	Designation      sql.NullString `json:"designation"`
	MarketingConsent int64          `json:"marketing_consent"`
	CreatedAt        time.Time      `json:"created_at"`
	WhitepaperTitle  string         `json:"whitepaper_title"`
}

func (q *Queries) ListWhitepaperDownloads(ctx context.Context, arg ListWhitepaperDownloadsParams) ([]ListWhitepaperDownloadsRow, error) {
	rows, err := q.db.QueryContext(ctx, listWhitepaperDownloads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWhitepaperDownloadsRow{}
	for rows.Next() {
		var i ListWhitepaperDownloadsRow
		if err := rows.Scan(
			&i.ID,
			&i.WhitepaperID,
			&i.Name,
			&i.Email,
			&i.Company,
			&i.Designation,
			&i.MarketingConsent,
			&i.CreatedAt,
			&i.WhitepaperTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWhitepaperDownloadsByWhitepaperId = `-- name: ListWhitepaperDownloadsByWhitepaperId :many
SELECT
    id, name, email, company, designation, marketing_consent, created_at
FROM whitepaper_downloads
WHERE whitepaper_id = ?
ORDER BY created_at DESC
`

type ListWhitepaperDownloadsByWhitepaperIdRow struct {
	ID               int64          `json:"id"`
	Name             string         `json:"name"`
	Email            string         `json:"email"`
	Company          string         `json:"company"`
	Designation      sql.NullString `json:"designation"`
	MarketingConsent int64          `json:"marketing_consent"`
	CreatedAt        time.Time      `json:"created_at"`
}

func (q *Queries) ListWhitepaperDownloadsByWhitepaperId(ctx context.Context, whitepaperID int64) ([]ListWhitepaperDownloadsByWhitepaperIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listWhitepaperDownloadsByWhitepaperId, whitepaperID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWhitepaperDownloadsByWhitepaperIdRow{}
	for rows.Next() {
		var i ListWhitepaperDownloadsByWhitepaperIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Company,
			&i.Designation,
			&i.MarketingConsent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWhitepaperDownloadsFiltered = `-- name: ListWhitepaperDownloadsFiltered :many
SELECT
    wd.id, wd.whitepaper_id, wd.name, wd.email, wd.company, wd.designation,
    wd.marketing_consent, wd.created_at,
    w.title as whitepaper_title
FROM whitepaper_downloads wd
INNER JOIN whitepapers w ON wd.whitepaper_id = w.id
WHERE
    (CASE WHEN ?1 = 0 THEN 1 ELSE wd.whitepaper_id = ?1 END)
    AND (CASE WHEN ?2 = '' THEN 1 ELSE wd.created_at >= ?2 END)
    AND (CASE WHEN ?3 = '' THEN 1 ELSE wd.created_at <= ?3 || ' 23:59:59' END)
ORDER BY wd.created_at DESC
LIMIT ?5 OFFSET ?4
`

type ListWhitepaperDownloadsFilteredParams struct {
	FilterWhitepaper interface{} `json:"filter_whitepaper"`
	FilterDateFrom   interface{} `json:"filter_date_from"`
	FilterDateTo     interface{} `json:"filter_date_to"`
	PageOffset       int64       `json:"page_offset"`
	PageLimit        int64       `json:"page_limit"`
}

type ListWhitepaperDownloadsFilteredRow struct {
	ID               int64          `json:"id"`
	WhitepaperID     int64          `json:"whitepaper_id"`
	Name             string         `json:"name"`
	Email            string         `json:"email"`
	Company          string         `json:"company"`
	Designation      sql.NullString `json:"designation"`
	MarketingConsent int64          `json:"marketing_consent"`
	CreatedAt        time.Time      `json:"created_at"`
	WhitepaperTitle  string         `json:"whitepaper_title"`
}

func (q *Queries) ListWhitepaperDownloadsFiltered(ctx context.Context, arg ListWhitepaperDownloadsFilteredParams) ([]ListWhitepaperDownloadsFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, listWhitepaperDownloadsFiltered,
		arg.FilterWhitepaper,
		arg.FilterDateFrom,
		arg.FilterDateTo,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWhitepaperDownloadsFilteredRow{}
	for rows.Next() {
		var i ListWhitepaperDownloadsFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.WhitepaperID,
			&i.Name,
			&i.Email,
			&i.Company,
			&i.Designation,
			&i.MarketingConsent,
			&i.CreatedAt,
			&i.WhitepaperTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWhitepaperTopicsWithCount = `-- name: ListWhitepaperTopicsWithCount :many
SELECT t.id, t.name, t.slug, t.color_hex, t.icon, t.description, t.sort_order, t.created_at, t.updated_at,
    (SELECT COUNT(*) FROM whitepapers w WHERE w.topic_id = t.id) as whitepaper_count
FROM whitepaper_topics t
ORDER BY t.sort_order ASC, t.name ASC
`

type ListWhitepaperTopicsWithCountRow struct {
	ID              int64          `json:"id"`
	Name            string         `json:"name"`
	Slug            string         `json:"slug"`
	ColorHex        string         `json:"color_hex"`
	Icon            string         `json:"icon"`
	Description     sql.NullString `json:"description"`
	SortOrder       int64          `json:"sort_order"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	WhitepaperCount int64          `json:"whitepaper_count"`
}

func (q *Queries) ListWhitepaperTopicsWithCount(ctx context.Context) ([]ListWhitepaperTopicsWithCountRow, error) {
	rows, err := q.db.QueryContext(ctx, listWhitepaperTopicsWithCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWhitepaperTopicsWithCountRow{}
	for rows.Next() {
		var i ListWhitepaperTopicsWithCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ColorHex,
			&i.Icon,
			&i.Description,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WhitepaperCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWhitepapersAdminFiltered = `-- name: ListWhitepapersAdminFiltered :many
SELECT
    w.id, w.title, w.slug, w.topic_id, w.is_published, w.published_date, w.download_count,
    w.created_at, w.updated_at,
    t.name as topic_name
FROM whitepapers w
INNER JOIN whitepaper_topics t ON w.topic_id = t.id
WHERE
    (CASE WHEN ?1 = '' THEN 1 ELSE w.title LIKE '%' || ?1 || '%' END)
    AND (CASE WHEN ?2 = 0 THEN 1 ELSE w.topic_id = ?2 END)
    AND (CASE WHEN ?3 = '' THEN 1
         WHEN ?3 = 'published' THEN w.is_published = 1
         WHEN ?3 = 'draft' THEN w.is_published = 0
         ELSE 1 END)
ORDER BY w.created_at DESC
LIMIT ?5 OFFSET ?4
`

type ListWhitepapersAdminFilteredParams struct {
	FilterSearch interface{} `json:"filter_search"`
	FilterTopic  interface{} `json:"filter_topic"`
	FilterStatus interface{} `json:"filter_status"`
	PageOffset   int64       `json:"page_offset"`
	PageLimit    int64       `json:"page_limit"`
}

type ListWhitepapersAdminFilteredRow struct {
	ID            int64     `json:"id"`
	Title         string    `json:"title"`
	Slug          string    `json:"slug"`
	TopicID       int64     `json:"topic_id"`
	IsPublished   int64     `json:"is_published"`
	PublishedDate string    `json:"published_date"`
	DownloadCount int64     `json:"download_count"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	TopicName     string    `json:"topic_name"`
}

func (q *Queries) ListWhitepapersAdminFiltered(ctx context.Context, arg ListWhitepapersAdminFilteredParams) ([]ListWhitepapersAdminFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, listWhitepapersAdminFiltered,
		arg.FilterSearch,
		arg.FilterTopic,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWhitepapersAdminFilteredRow{}
	for rows.Next() {
		var i ListWhitepapersAdminFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.TopicID,
			&i.IsPublished,
			&i.PublishedDate,
			&i.DownloadCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TopicName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWhitepaper = `-- name: UpdateWhitepaper :exec
UPDATE whitepapers
SET title = ?, slug = ?, description = ?, topic_id = ?, pdf_file_path = ?,
    file_size_bytes = ?, page_count = ?, published_date = ?, is_published = ?,
    cover_color_from = ?, cover_color_to = ?, meta_description = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateWhitepaperParams struct {
	Title           string         `json:"title"`
	Slug            string         `json:"slug"`
	Description     string         `json:"description"`
	TopicID         int64          `json:"topic_id"`
	PdfFilePath     string         `json:"pdf_file_path"`
	FileSizeBytes   int64          `json:"file_size_bytes"`
	PageCount       sql.NullInt64  `json:"page_count"`
	PublishedDate   string         `json:"published_date"`
	IsPublished     int64          `json:"is_published"`
	CoverColorFrom  string         `json:"cover_color_from"`
	CoverColorTo    string         `json:"cover_color_to"`
	MetaDescription sql.NullString `json:"meta_description"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateWhitepaper(ctx context.Context, arg UpdateWhitepaperParams) error {
	_, err := q.db.ExecContext(ctx, updateWhitepaper,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.TopicID,
		arg.PdfFilePath,
		arg.FileSizeBytes,
		arg.PageCount,
		arg.PublishedDate,
		arg.IsPublished,
		arg.CoverColorFrom,
		arg.CoverColorTo,
		arg.MetaDescription,
		arg.ID,
	)
	return err
}
