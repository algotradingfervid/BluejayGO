// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contact.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const bulkMarkContactSubmissionsRead = `-- name: BulkMarkContactSubmissionsRead :exec
UPDATE contact_submissions
SET status = 'read', updated_at = CURRENT_TIMESTAMP
WHERE status = 'new'
`

func (q *Queries) BulkMarkContactSubmissionsRead(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, bulkMarkContactSubmissionsRead)
	return err
}

const countContactSubmissions = `-- name: CountContactSubmissions :one
SELECT COUNT(*) FROM contact_submissions
`

func (q *Queries) CountContactSubmissions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContactSubmissions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContactSubmissionsByStatus = `-- name: CountContactSubmissionsByStatus :one
SELECT COUNT(*) FROM contact_submissions WHERE status = ?
`

func (q *Queries) CountContactSubmissionsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContactSubmissionsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContactSubmissionsByStatusAndType = `-- name: CountContactSubmissionsByStatusAndType :one
SELECT COUNT(*) FROM contact_submissions WHERE status = ? AND submission_type = ?
`

type CountContactSubmissionsByStatusAndTypeParams struct {
	Status         string `json:"status"`
	SubmissionType string `json:"submission_type"`
}

func (q *Queries) CountContactSubmissionsByStatusAndType(ctx context.Context, arg CountContactSubmissionsByStatusAndTypeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContactSubmissionsByStatusAndType, arg.Status, arg.SubmissionType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContactSubmissionsByType = `-- name: CountContactSubmissionsByType :one
SELECT COUNT(*) FROM contact_submissions WHERE submission_type = ?
`

func (q *Queries) CountContactSubmissionsByType(ctx context.Context, submissionType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContactSubmissionsByType, submissionType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContactSubmissionsSearch = `-- name: CountContactSubmissionsSearch :one
SELECT COUNT(*) FROM contact_submissions
WHERE (name LIKE '%' || ? || '%' OR email LIKE '%' || ? || '%' OR company LIKE '%' || ? || '%' OR message LIKE '%' || ? || '%')
`

type CountContactSubmissionsSearchParams struct {
	Column1 sql.NullString `json:"column_1"`
	Column2 sql.NullString `json:"column_2"`
	Column3 sql.NullString `json:"column_3"`
	Column4 sql.NullString `json:"column_4"`
}

func (q *Queries) CountContactSubmissionsSearch(ctx context.Context, arg CountContactSubmissionsSearchParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countContactSubmissionsSearch,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContactSubmission = `-- name: CreateContactSubmission :one

INSERT INTO contact_submissions (
    name, email, phone, company, inquiry_type, message, ip_address, user_agent
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, created_at
`

type CreateContactSubmissionParams struct {
	Name        string         `json:"name"`
	Email       string         `json:"email"`
	Phone       string         `json:"phone"`
	Company     string         `json:"company"`
	InquiryType sql.NullString `json:"inquiry_type"`
	Message     string         `json:"message"`
	IpAddress   sql.NullString `json:"ip_address"`
	UserAgent   sql.NullString `json:"user_agent"`
}

type CreateContactSubmissionRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
}

// ====================================================================
// CONTACT SUBMISSIONS
// ====================================================================
func (q *Queries) CreateContactSubmission(ctx context.Context, arg CreateContactSubmissionParams) (CreateContactSubmissionRow, error) {
	row := q.db.QueryRowContext(ctx, createContactSubmission,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Company,
		arg.InquiryType,
		arg.Message,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i CreateContactSubmissionRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createOfficeLocation = `-- name: CreateOfficeLocation :one
INSERT INTO office_locations (
    name, address_line1, address_line2, city, state, postal_code, country,
    phone, email, is_primary, is_active, display_order
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, created_at, updated_at
`

type CreateOfficeLocationParams struct {
	Name         string         `json:"name"`
	AddressLine1 string         `json:"address_line1"`
	AddressLine2 sql.NullString `json:"address_line2"`
	City         string         `json:"city"`
	State        string         `json:"state"`
	PostalCode   string         `json:"postal_code"`
	Country      string         `json:"country"`
	Phone        sql.NullString `json:"phone"`
	Email        sql.NullString `json:"email"`
	IsPrimary    int64          `json:"is_primary"`
	IsActive     int64          `json:"is_active"`
	DisplayOrder int64          `json:"display_order"`
}

type CreateOfficeLocationRow struct {
	ID        int64     `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) CreateOfficeLocation(ctx context.Context, arg CreateOfficeLocationParams) (CreateOfficeLocationRow, error) {
	row := q.db.QueryRowContext(ctx, createOfficeLocation,
		arg.Name,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
		arg.Email,
		arg.IsPrimary,
		arg.IsActive,
		arg.DisplayOrder,
	)
	var i CreateOfficeLocationRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const deleteContactSubmission = `-- name: DeleteContactSubmission :exec
DELETE FROM contact_submissions WHERE id = ?
`

func (q *Queries) DeleteContactSubmission(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteContactSubmission, id)
	return err
}

const deleteOfficeLocation = `-- name: DeleteOfficeLocation :exec
DELETE FROM office_locations WHERE id = ?
`

func (q *Queries) DeleteOfficeLocation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOfficeLocation, id)
	return err
}

const getActiveOfficeLocations = `-- name: GetActiveOfficeLocations :many
SELECT id, name, address_line1, address_line2, city, state, postal_code, country, phone, email, is_primary
FROM office_locations
WHERE is_active = 1
ORDER BY is_primary DESC, display_order ASC, id ASC
`

type GetActiveOfficeLocationsRow struct {
	ID           int64          `json:"id"`
	Name         string         `json:"name"`
	AddressLine1 string         `json:"address_line1"`
	AddressLine2 sql.NullString `json:"address_line2"`
	City         string         `json:"city"`
	State        string         `json:"state"`
	PostalCode   string         `json:"postal_code"`
	Country      string         `json:"country"`
	Phone        sql.NullString `json:"phone"`
	Email        sql.NullString `json:"email"`
	IsPrimary    int64          `json:"is_primary"`
}

func (q *Queries) GetActiveOfficeLocations(ctx context.Context) ([]GetActiveOfficeLocationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveOfficeLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveOfficeLocationsRow{}
	for rows.Next() {
		var i GetActiveOfficeLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Email,
			&i.IsPrimary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactSubmissionByID = `-- name: GetContactSubmissionByID :one
SELECT id, name, email, phone, company, inquiry_type, message, ip_address, user_agent,
       status, notes, submission_type, created_at, updated_at
FROM contact_submissions
WHERE id = ?
`

type GetContactSubmissionByIDRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	Phone          string         `json:"phone"`
	Company        string         `json:"company"`
	InquiryType    sql.NullString `json:"inquiry_type"`
	Message        string         `json:"message"`
	IpAddress      sql.NullString `json:"ip_address"`
	UserAgent      sql.NullString `json:"user_agent"`
	Status         string         `json:"status"`
	Notes          sql.NullString `json:"notes"`
	SubmissionType string         `json:"submission_type"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) GetContactSubmissionByID(ctx context.Context, id int64) (GetContactSubmissionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getContactSubmissionByID, id)
	var i GetContactSubmissionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Company,
		&i.InquiryType,
		&i.Message,
		&i.IpAddress,
		&i.UserAgent,
		&i.Status,
		&i.Notes,
		&i.SubmissionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextSubmissionID = `-- name: GetNextSubmissionID :one
SELECT cs.id FROM contact_submissions cs WHERE cs.created_at < (SELECT cs2.created_at FROM contact_submissions cs2 WHERE cs2.id = ?) ORDER BY cs.created_at DESC LIMIT 1
`

func (q *Queries) GetNextSubmissionID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNextSubmissionID, id)
	err := row.Scan(&id)
	return id, err
}

const getOfficeLocationByID = `-- name: GetOfficeLocationByID :one
SELECT id, name, address_line1, address_line2, city, state, postal_code, country,
       phone, email, is_primary, is_active, display_order
FROM office_locations
WHERE id = ?
`

type GetOfficeLocationByIDRow struct {
	ID           int64          `json:"id"`
	Name         string         `json:"name"`
	AddressLine1 string         `json:"address_line1"`
	AddressLine2 sql.NullString `json:"address_line2"`
	City         string         `json:"city"`
	State        string         `json:"state"`
	PostalCode   string         `json:"postal_code"`
	Country      string         `json:"country"`
	Phone        sql.NullString `json:"phone"`
	Email        sql.NullString `json:"email"`
	IsPrimary    int64          `json:"is_primary"`
	IsActive     int64          `json:"is_active"`
	DisplayOrder int64          `json:"display_order"`
}

func (q *Queries) GetOfficeLocationByID(ctx context.Context, id int64) (GetOfficeLocationByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOfficeLocationByID, id)
	var i GetOfficeLocationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Phone,
		&i.Email,
		&i.IsPrimary,
		&i.IsActive,
		&i.DisplayOrder,
	)
	return i, err
}

const getPreviousSubmissionID = `-- name: GetPreviousSubmissionID :one
SELECT cs.id FROM contact_submissions cs WHERE cs.created_at > (SELECT cs2.created_at FROM contact_submissions cs2 WHERE cs2.id = ?) ORDER BY cs.created_at ASC LIMIT 1
`

func (q *Queries) GetPreviousSubmissionID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPreviousSubmissionID, id)
	err := row.Scan(&id)
	return id, err
}

const listAllOfficeLocations = `-- name: ListAllOfficeLocations :many

SELECT id, name, address_line1, address_line2, city, state, postal_code, country,
       phone, email, is_primary, is_active, display_order, created_at, updated_at
FROM office_locations
ORDER BY display_order ASC, id ASC
`

// ====================================================================
// OFFICE LOCATIONS - ADMIN
// ====================================================================
func (q *Queries) ListAllOfficeLocations(ctx context.Context) ([]OfficeLocation, error) {
	rows, err := q.db.QueryContext(ctx, listAllOfficeLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OfficeLocation{}
	for rows.Next() {
		var i OfficeLocation
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.Phone,
			&i.Email,
			&i.IsPrimary,
			&i.IsActive,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactSubmissions = `-- name: ListContactSubmissions :many

SELECT id, name, email, phone, company, inquiry_type, message, status, submission_type, created_at, updated_at
FROM contact_submissions
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListContactSubmissionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListContactSubmissionsRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	Phone          string         `json:"phone"`
	Company        string         `json:"company"`
	InquiryType    sql.NullString `json:"inquiry_type"`
	Message        string         `json:"message"`
	Status         string         `json:"status"`
	SubmissionType string         `json:"submission_type"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

// ====================================================================
// CONTACT - ADMIN
// ====================================================================
func (q *Queries) ListContactSubmissions(ctx context.Context, arg ListContactSubmissionsParams) ([]ListContactSubmissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listContactSubmissions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactSubmissionsRow{}
	for rows.Next() {
		var i ListContactSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Company,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.SubmissionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactSubmissionsByStatus = `-- name: ListContactSubmissionsByStatus :many
SELECT id, name, email, phone, company, inquiry_type, message, status, submission_type, created_at, updated_at
FROM contact_submissions
WHERE status = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListContactSubmissionsByStatusParams struct {
	Status string `json:"status"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

type ListContactSubmissionsByStatusRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	Phone          string         `json:"phone"`
	Company        string         `json:"company"`
	InquiryType    sql.NullString `json:"inquiry_type"`
	Message        string         `json:"message"`
	Status         string         `json:"status"`
	SubmissionType string         `json:"submission_type"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) ListContactSubmissionsByStatus(ctx context.Context, arg ListContactSubmissionsByStatusParams) ([]ListContactSubmissionsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listContactSubmissionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactSubmissionsByStatusRow{}
	for rows.Next() {
		var i ListContactSubmissionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Company,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.SubmissionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactSubmissionsByStatusAndType = `-- name: ListContactSubmissionsByStatusAndType :many
SELECT id, name, email, phone, company, inquiry_type, message, status, submission_type, created_at, updated_at
FROM contact_submissions
WHERE status = ? AND submission_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListContactSubmissionsByStatusAndTypeParams struct {
	Status         string `json:"status"`
	SubmissionType string `json:"submission_type"`
	Limit          int64  `json:"limit"`
	Offset         int64  `json:"offset"`
}

type ListContactSubmissionsByStatusAndTypeRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	Phone          string         `json:"phone"`
	Company        string         `json:"company"`
	InquiryType    sql.NullString `json:"inquiry_type"`
	Message        string         `json:"message"`
	Status         string         `json:"status"`
	SubmissionType string         `json:"submission_type"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) ListContactSubmissionsByStatusAndType(ctx context.Context, arg ListContactSubmissionsByStatusAndTypeParams) ([]ListContactSubmissionsByStatusAndTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, listContactSubmissionsByStatusAndType,
		arg.Status,
		arg.SubmissionType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactSubmissionsByStatusAndTypeRow{}
	for rows.Next() {
		var i ListContactSubmissionsByStatusAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Company,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.SubmissionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactSubmissionsByType = `-- name: ListContactSubmissionsByType :many
SELECT id, name, email, phone, company, inquiry_type, message, status, submission_type, created_at, updated_at
FROM contact_submissions
WHERE submission_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListContactSubmissionsByTypeParams struct {
	SubmissionType string `json:"submission_type"`
	Limit          int64  `json:"limit"`
	Offset         int64  `json:"offset"`
}

type ListContactSubmissionsByTypeRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	Phone          string         `json:"phone"`
	Company        string         `json:"company"`
	InquiryType    sql.NullString `json:"inquiry_type"`
	Message        string         `json:"message"`
	Status         string         `json:"status"`
	SubmissionType string         `json:"submission_type"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) ListContactSubmissionsByType(ctx context.Context, arg ListContactSubmissionsByTypeParams) ([]ListContactSubmissionsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, listContactSubmissionsByType, arg.SubmissionType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactSubmissionsByTypeRow{}
	for rows.Next() {
		var i ListContactSubmissionsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Company,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.SubmissionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContactSubmissions = `-- name: SearchContactSubmissions :many
SELECT id, name, email, phone, company, inquiry_type, message, status, submission_type, created_at, updated_at
FROM contact_submissions
WHERE (name LIKE '%' || ? || '%' OR email LIKE '%' || ? || '%' OR company LIKE '%' || ? || '%' OR message LIKE '%' || ? || '%')
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchContactSubmissionsParams struct {
	Column1 sql.NullString `json:"column_1"`
	Column2 sql.NullString `json:"column_2"`
	Column3 sql.NullString `json:"column_3"`
	Column4 sql.NullString `json:"column_4"`
	Limit   int64          `json:"limit"`
	Offset  int64          `json:"offset"`
}

type SearchContactSubmissionsRow struct {
	ID             int64          `json:"id"`
	Name           string         `json:"name"`
	Email          string         `json:"email"`
	Phone          string         `json:"phone"`
	Company        string         `json:"company"`
	InquiryType    sql.NullString `json:"inquiry_type"`
	Message        string         `json:"message"`
	Status         string         `json:"status"`
	SubmissionType string         `json:"submission_type"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) SearchContactSubmissions(ctx context.Context, arg SearchContactSubmissionsParams) ([]SearchContactSubmissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchContactSubmissions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchContactSubmissionsRow{}
	for rows.Next() {
		var i SearchContactSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Company,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.SubmissionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unsetPrimaryOfficeLocations = `-- name: UnsetPrimaryOfficeLocations :exec
UPDATE office_locations SET is_primary = 0 WHERE is_primary = 1
`

func (q *Queries) UnsetPrimaryOfficeLocations(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, unsetPrimaryOfficeLocations)
	return err
}

const updateContactSubmissionStatus = `-- name: UpdateContactSubmissionStatus :exec
UPDATE contact_submissions
SET status = ?, notes = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateContactSubmissionStatusParams struct {
	Status string         `json:"status"`
	Notes  sql.NullString `json:"notes"`
	ID     int64          `json:"id"`
}

func (q *Queries) UpdateContactSubmissionStatus(ctx context.Context, arg UpdateContactSubmissionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateContactSubmissionStatus, arg.Status, arg.Notes, arg.ID)
	return err
}

const updateOfficeLocation = `-- name: UpdateOfficeLocation :exec
UPDATE office_locations
SET name = ?, address_line1 = ?, address_line2 = ?, city = ?, state = ?,
    postal_code = ?, country = ?, phone = ?, email = ?, is_primary = ?,
    is_active = ?, display_order = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOfficeLocationParams struct {
	Name         string         `json:"name"`
	AddressLine1 string         `json:"address_line1"`
	AddressLine2 sql.NullString `json:"address_line2"`
	City         string         `json:"city"`
	State        string         `json:"state"`
	PostalCode   string         `json:"postal_code"`
	Country      string         `json:"country"`
	Phone        sql.NullString `json:"phone"`
	Email        sql.NullString `json:"email"`
	IsPrimary    int64          `json:"is_primary"`
	IsActive     int64          `json:"is_active"`
	DisplayOrder int64          `json:"display_order"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateOfficeLocation(ctx context.Context, arg UpdateOfficeLocationParams) error {
	_, err := q.db.ExecContext(ctx, updateOfficeLocation,
		arg.Name,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Phone,
		arg.Email,
		arg.IsPrimary,
		arg.IsActive,
		arg.DisplayOrder,
		arg.ID,
	)
	return err
}
