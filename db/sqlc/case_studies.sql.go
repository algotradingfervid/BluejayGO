// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: case_studies.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const adminAddCaseStudyProduct = `-- name: AdminAddCaseStudyProduct :one

INSERT INTO case_study_products (case_study_id, product_id, display_order)
VALUES (?, ?, ?)
ON CONFLICT (case_study_id, product_id) DO UPDATE
SET display_order = EXCLUDED.display_order
RETURNING id, case_study_id, product_id, display_order, created_at
`

type AdminAddCaseStudyProductParams struct {
	CaseStudyID  int64 `json:"case_study_id"`
	ProductID    int64 `json:"product_id"`
	DisplayOrder int64 `json:"display_order"`
}

// Case study products management
func (q *Queries) AdminAddCaseStudyProduct(ctx context.Context, arg AdminAddCaseStudyProductParams) (CaseStudyProduct, error) {
	row := q.db.QueryRowContext(ctx, adminAddCaseStudyProduct, arg.CaseStudyID, arg.ProductID, arg.DisplayOrder)
	var i CaseStudyProduct
	err := row.Scan(
		&i.ID,
		&i.CaseStudyID,
		&i.ProductID,
		&i.DisplayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const adminCreateCaseStudy = `-- name: AdminCreateCaseStudy :one
INSERT INTO case_studies (
    slug, title, client_name, industry_id, hero_image_url, summary,
    challenge_title, challenge_content, challenge_bullets,
    solution_title, solution_content,
    outcome_title, outcome_content,
    meta_title, meta_description, is_published, display_order
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?,
    ?, ?,
    ?, ?, ?, ?
) RETURNING id, slug, title, client_name, industry_id, hero_image_url, summary, challenge_title, challenge_content, challenge_bullets, solution_title, solution_content, outcome_title, outcome_content, meta_title, meta_description, is_published, display_order, created_at, updated_at, og_image
`

type AdminCreateCaseStudyParams struct {
	Slug             string         `json:"slug"`
	Title            string         `json:"title"`
	ClientName       string         `json:"client_name"`
	IndustryID       int64          `json:"industry_id"`
	HeroImageUrl     sql.NullString `json:"hero_image_url"`
	Summary          string         `json:"summary"`
	ChallengeTitle   string         `json:"challenge_title"`
	ChallengeContent string         `json:"challenge_content"`
	ChallengeBullets sql.NullString `json:"challenge_bullets"`
	SolutionTitle    string         `json:"solution_title"`
	SolutionContent  string         `json:"solution_content"`
	OutcomeTitle     string         `json:"outcome_title"`
	OutcomeContent   string         `json:"outcome_content"`
	MetaTitle        sql.NullString `json:"meta_title"`
	MetaDescription  sql.NullString `json:"meta_description"`
	IsPublished      int64          `json:"is_published"`
	DisplayOrder     int64          `json:"display_order"`
}

func (q *Queries) AdminCreateCaseStudy(ctx context.Context, arg AdminCreateCaseStudyParams) (CaseStudy, error) {
	row := q.db.QueryRowContext(ctx, adminCreateCaseStudy,
		arg.Slug,
		arg.Title,
		arg.ClientName,
		arg.IndustryID,
		arg.HeroImageUrl,
		arg.Summary,
		arg.ChallengeTitle,
		arg.ChallengeContent,
		arg.ChallengeBullets,
		arg.SolutionTitle,
		arg.SolutionContent,
		arg.OutcomeTitle,
		arg.OutcomeContent,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.DisplayOrder,
	)
	var i CaseStudy
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.ClientName,
		&i.IndustryID,
		&i.HeroImageUrl,
		&i.Summary,
		&i.ChallengeTitle,
		&i.ChallengeContent,
		&i.ChallengeBullets,
		&i.SolutionTitle,
		&i.SolutionContent,
		&i.OutcomeTitle,
		&i.OutcomeContent,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OgImage,
	)
	return i, err
}

const adminCreateMetric = `-- name: AdminCreateMetric :one

INSERT INTO case_study_metrics (case_study_id, metric_value, metric_label, display_order)
VALUES (?, ?, ?, ?)
RETURNING id, case_study_id, metric_value, metric_label, display_order, created_at
`

type AdminCreateMetricParams struct {
	CaseStudyID  int64  `json:"case_study_id"`
	MetricValue  string `json:"metric_value"`
	MetricLabel  string `json:"metric_label"`
	DisplayOrder int64  `json:"display_order"`
}

// Metrics management
func (q *Queries) AdminCreateMetric(ctx context.Context, arg AdminCreateMetricParams) (CaseStudyMetric, error) {
	row := q.db.QueryRowContext(ctx, adminCreateMetric,
		arg.CaseStudyID,
		arg.MetricValue,
		arg.MetricLabel,
		arg.DisplayOrder,
	)
	var i CaseStudyMetric
	err := row.Scan(
		&i.ID,
		&i.CaseStudyID,
		&i.MetricValue,
		&i.MetricLabel,
		&i.DisplayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const adminDeleteCaseStudy = `-- name: AdminDeleteCaseStudy :exec
DELETE FROM case_studies WHERE id = ?
`

func (q *Queries) AdminDeleteCaseStudy(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, adminDeleteCaseStudy, id)
	return err
}

const adminDeleteMetric = `-- name: AdminDeleteMetric :exec
DELETE FROM case_study_metrics WHERE id = ?
`

func (q *Queries) AdminDeleteMetric(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, adminDeleteMetric, id)
	return err
}

const adminGetCaseStudy = `-- name: AdminGetCaseStudy :one
SELECT id, slug, title, client_name, industry_id, hero_image_url, summary, challenge_title, challenge_content, challenge_bullets, solution_title, solution_content, outcome_title, outcome_content, meta_title, meta_description, is_published, display_order, created_at, updated_at, og_image FROM case_studies WHERE id = ?
`

func (q *Queries) AdminGetCaseStudy(ctx context.Context, id int64) (CaseStudy, error) {
	row := q.db.QueryRowContext(ctx, adminGetCaseStudy, id)
	var i CaseStudy
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.ClientName,
		&i.IndustryID,
		&i.HeroImageUrl,
		&i.Summary,
		&i.ChallengeTitle,
		&i.ChallengeContent,
		&i.ChallengeBullets,
		&i.SolutionTitle,
		&i.SolutionContent,
		&i.OutcomeTitle,
		&i.OutcomeContent,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OgImage,
	)
	return i, err
}

const adminListCaseStudies = `-- name: AdminListCaseStudies :many

SELECT
    cs.id, cs.slug, cs.title, cs.client_name,
    cs.is_published, cs.display_order, cs.created_at,
    i.name as industry_name
FROM case_studies cs
INNER JOIN industries i ON cs.industry_id = i.id
ORDER BY cs.display_order ASC, cs.created_at DESC
`

type AdminListCaseStudiesRow struct {
	ID           int64     `json:"id"`
	Slug         string    `json:"slug"`
	Title        string    `json:"title"`
	ClientName   string    `json:"client_name"`
	IsPublished  int64     `json:"is_published"`
	DisplayOrder int64     `json:"display_order"`
	CreatedAt    time.Time `json:"created_at"`
	IndustryName string    `json:"industry_name"`
}

// Admin queries
func (q *Queries) AdminListCaseStudies(ctx context.Context) ([]AdminListCaseStudiesRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListCaseStudies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListCaseStudiesRow{}
	for rows.Next() {
		var i AdminListCaseStudiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.ClientName,
			&i.IsPublished,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.IndustryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListCaseStudiesFiltered = `-- name: AdminListCaseStudiesFiltered :many
SELECT
    cs.id, cs.slug, cs.title, cs.client_name,
    cs.hero_image_url, cs.is_published, cs.display_order,
    cs.updated_at,
    i.name as industry_name
FROM case_studies cs
INNER JOIN industries i ON cs.industry_id = i.id
WHERE
    (CASE WHEN ?1 = '' THEN 1 ELSE (cs.title LIKE '%' || ?1 || '%' OR cs.client_name LIKE '%' || ?1 || '%') END)
    AND (CASE WHEN ?2 = '' THEN 1
         WHEN ?2 = 'published' THEN cs.is_published = 1
         WHEN ?2 = 'draft' THEN cs.is_published = 0
         ELSE 1 END)
ORDER BY cs.display_order ASC, cs.created_at DESC
LIMIT ?4 OFFSET ?3
`

type AdminListCaseStudiesFilteredParams struct {
	FilterSearch interface{} `json:"filter_search"`
	FilterStatus interface{} `json:"filter_status"`
	PageOffset   int64       `json:"page_offset"`
	PageLimit    int64       `json:"page_limit"`
}

type AdminListCaseStudiesFilteredRow struct {
	ID           int64          `json:"id"`
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	ClientName   string         `json:"client_name"`
	HeroImageUrl sql.NullString `json:"hero_image_url"`
	IsPublished  int64          `json:"is_published"`
	DisplayOrder int64          `json:"display_order"`
	UpdatedAt    time.Time      `json:"updated_at"`
	IndustryName string         `json:"industry_name"`
}

func (q *Queries) AdminListCaseStudiesFiltered(ctx context.Context, arg AdminListCaseStudiesFilteredParams) ([]AdminListCaseStudiesFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListCaseStudiesFiltered,
		arg.FilterSearch,
		arg.FilterStatus,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListCaseStudiesFilteredRow{}
	for rows.Next() {
		var i AdminListCaseStudiesFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.ClientName,
			&i.HeroImageUrl,
			&i.IsPublished,
			&i.DisplayOrder,
			&i.UpdatedAt,
			&i.IndustryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListCaseStudyProducts = `-- name: AdminListCaseStudyProducts :many
SELECT
    csp.id, csp.product_id, csp.display_order,
    p.name as product_name, p.slug as product_slug
FROM case_study_products csp
INNER JOIN products p ON csp.product_id = p.id
WHERE csp.case_study_id = ?
ORDER BY csp.display_order ASC
`

type AdminListCaseStudyProductsRow struct {
	ID           int64  `json:"id"`
	ProductID    int64  `json:"product_id"`
	DisplayOrder int64  `json:"display_order"`
	ProductName  string `json:"product_name"`
	ProductSlug  string `json:"product_slug"`
}

func (q *Queries) AdminListCaseStudyProducts(ctx context.Context, caseStudyID int64) ([]AdminListCaseStudyProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListCaseStudyProducts, caseStudyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListCaseStudyProductsRow{}
	for rows.Next() {
		var i AdminListCaseStudyProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.DisplayOrder,
			&i.ProductName,
			&i.ProductSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListMetrics = `-- name: AdminListMetrics :many
SELECT id, case_study_id, metric_value, metric_label, display_order
FROM case_study_metrics
WHERE case_study_id = ?
ORDER BY display_order ASC
`

type AdminListMetricsRow struct {
	ID           int64  `json:"id"`
	CaseStudyID  int64  `json:"case_study_id"`
	MetricValue  string `json:"metric_value"`
	MetricLabel  string `json:"metric_label"`
	DisplayOrder int64  `json:"display_order"`
}

func (q *Queries) AdminListMetrics(ctx context.Context, caseStudyID int64) ([]AdminListMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListMetrics, caseStudyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListMetricsRow{}
	for rows.Next() {
		var i AdminListMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.CaseStudyID,
			&i.MetricValue,
			&i.MetricLabel,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminRemoveCaseStudyProduct = `-- name: AdminRemoveCaseStudyProduct :exec
DELETE FROM case_study_products
WHERE case_study_id = ? AND product_id = ?
`

type AdminRemoveCaseStudyProductParams struct {
	CaseStudyID int64 `json:"case_study_id"`
	ProductID   int64 `json:"product_id"`
}

func (q *Queries) AdminRemoveCaseStudyProduct(ctx context.Context, arg AdminRemoveCaseStudyProductParams) error {
	_, err := q.db.ExecContext(ctx, adminRemoveCaseStudyProduct, arg.CaseStudyID, arg.ProductID)
	return err
}

const adminUpdateCaseStudy = `-- name: AdminUpdateCaseStudy :one
UPDATE case_studies SET
    slug = ?,
    title = ?,
    client_name = ?,
    industry_id = ?,
    hero_image_url = ?,
    summary = ?,
    challenge_title = ?,
    challenge_content = ?,
    challenge_bullets = ?,
    solution_title = ?,
    solution_content = ?,
    outcome_title = ?,
    outcome_content = ?,
    meta_title = ?,
    meta_description = ?,
    is_published = ?,
    display_order = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slug, title, client_name, industry_id, hero_image_url, summary, challenge_title, challenge_content, challenge_bullets, solution_title, solution_content, outcome_title, outcome_content, meta_title, meta_description, is_published, display_order, created_at, updated_at, og_image
`

type AdminUpdateCaseStudyParams struct {
	Slug             string         `json:"slug"`
	Title            string         `json:"title"`
	ClientName       string         `json:"client_name"`
	IndustryID       int64          `json:"industry_id"`
	HeroImageUrl     sql.NullString `json:"hero_image_url"`
	Summary          string         `json:"summary"`
	ChallengeTitle   string         `json:"challenge_title"`
	ChallengeContent string         `json:"challenge_content"`
	ChallengeBullets sql.NullString `json:"challenge_bullets"`
	SolutionTitle    string         `json:"solution_title"`
	SolutionContent  string         `json:"solution_content"`
	OutcomeTitle     string         `json:"outcome_title"`
	OutcomeContent   string         `json:"outcome_content"`
	MetaTitle        sql.NullString `json:"meta_title"`
	MetaDescription  sql.NullString `json:"meta_description"`
	IsPublished      int64          `json:"is_published"`
	DisplayOrder     int64          `json:"display_order"`
	ID               int64          `json:"id"`
}

func (q *Queries) AdminUpdateCaseStudy(ctx context.Context, arg AdminUpdateCaseStudyParams) (CaseStudy, error) {
	row := q.db.QueryRowContext(ctx, adminUpdateCaseStudy,
		arg.Slug,
		arg.Title,
		arg.ClientName,
		arg.IndustryID,
		arg.HeroImageUrl,
		arg.Summary,
		arg.ChallengeTitle,
		arg.ChallengeContent,
		arg.ChallengeBullets,
		arg.SolutionTitle,
		arg.SolutionContent,
		arg.OutcomeTitle,
		arg.OutcomeContent,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.IsPublished,
		arg.DisplayOrder,
		arg.ID,
	)
	var i CaseStudy
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.ClientName,
		&i.IndustryID,
		&i.HeroImageUrl,
		&i.Summary,
		&i.ChallengeTitle,
		&i.ChallengeContent,
		&i.ChallengeBullets,
		&i.SolutionTitle,
		&i.SolutionContent,
		&i.OutcomeTitle,
		&i.OutcomeContent,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.IsPublished,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OgImage,
	)
	return i, err
}

const adminUpdateMetric = `-- name: AdminUpdateMetric :one
UPDATE case_study_metrics SET
    metric_value = ?,
    metric_label = ?,
    display_order = ?
WHERE id = ?
RETURNING id, case_study_id, metric_value, metric_label, display_order, created_at
`

type AdminUpdateMetricParams struct {
	MetricValue  string `json:"metric_value"`
	MetricLabel  string `json:"metric_label"`
	DisplayOrder int64  `json:"display_order"`
	ID           int64  `json:"id"`
}

func (q *Queries) AdminUpdateMetric(ctx context.Context, arg AdminUpdateMetricParams) (CaseStudyMetric, error) {
	row := q.db.QueryRowContext(ctx, adminUpdateMetric,
		arg.MetricValue,
		arg.MetricLabel,
		arg.DisplayOrder,
		arg.ID,
	)
	var i CaseStudyMetric
	err := row.Scan(
		&i.ID,
		&i.CaseStudyID,
		&i.MetricValue,
		&i.MetricLabel,
		&i.DisplayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const countCaseStudies = `-- name: CountCaseStudies :one
SELECT COUNT(*) FROM case_studies WHERE is_published = 1
`

func (q *Queries) CountCaseStudies(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCaseStudies)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCaseStudiesAdminFiltered = `-- name: CountCaseStudiesAdminFiltered :one
SELECT COUNT(*) FROM case_studies cs
WHERE
    (CASE WHEN ?1 = '' THEN 1 ELSE (cs.title LIKE '%' || ?1 || '%' OR cs.client_name LIKE '%' || ?1 || '%') END)
    AND (CASE WHEN ?2 = '' THEN 1
         WHEN ?2 = 'published' THEN cs.is_published = 1
         WHEN ?2 = 'draft' THEN cs.is_published = 0
         ELSE 1 END)
`

type CountCaseStudiesAdminFilteredParams struct {
	FilterSearch interface{} `json:"filter_search"`
	FilterStatus interface{} `json:"filter_status"`
}

func (q *Queries) CountCaseStudiesAdminFiltered(ctx context.Context, arg CountCaseStudiesAdminFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCaseStudiesAdminFiltered, arg.FilterSearch, arg.FilterStatus)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCaseStudiesByIndustry = `-- name: CountCaseStudiesByIndustry :one
SELECT COUNT(*) FROM case_studies WHERE is_published = 1 AND industry_id = ?
`

func (q *Queries) CountCaseStudiesByIndustry(ctx context.Context, industryID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCaseStudiesByIndustry, industryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCaseStudyBySlug = `-- name: GetCaseStudyBySlug :one
SELECT
    cs.id, cs.slug, cs.title, cs.client_name, cs.summary,
    cs.industry_id, cs.hero_image_url,
    cs.challenge_title, cs.challenge_content, cs.challenge_bullets,
    cs.solution_title, cs.solution_content,
    cs.outcome_title, cs.outcome_content,
    cs.meta_title, cs.meta_description, cs.og_image, cs.created_at,
    i.name as industry_name, i.slug as industry_slug
FROM case_studies cs
INNER JOIN industries i ON cs.industry_id = i.id
WHERE cs.slug = ? AND cs.is_published = 1
`

type GetCaseStudyBySlugRow struct {
	ID               int64          `json:"id"`
	Slug             string         `json:"slug"`
	Title            string         `json:"title"`
	ClientName       string         `json:"client_name"`
	Summary          string         `json:"summary"`
	IndustryID       int64          `json:"industry_id"`
	HeroImageUrl     sql.NullString `json:"hero_image_url"`
	ChallengeTitle   string         `json:"challenge_title"`
	ChallengeContent string         `json:"challenge_content"`
	ChallengeBullets sql.NullString `json:"challenge_bullets"`
	SolutionTitle    string         `json:"solution_title"`
	SolutionContent  string         `json:"solution_content"`
	OutcomeTitle     string         `json:"outcome_title"`
	OutcomeContent   string         `json:"outcome_content"`
	MetaTitle        sql.NullString `json:"meta_title"`
	MetaDescription  sql.NullString `json:"meta_description"`
	OgImage          string         `json:"og_image"`
	CreatedAt        time.Time      `json:"created_at"`
	IndustryName     string         `json:"industry_name"`
	IndustrySlug     string         `json:"industry_slug"`
}

func (q *Queries) GetCaseStudyBySlug(ctx context.Context, slug string) (GetCaseStudyBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getCaseStudyBySlug, slug)
	var i GetCaseStudyBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.ClientName,
		&i.Summary,
		&i.IndustryID,
		&i.HeroImageUrl,
		&i.ChallengeTitle,
		&i.ChallengeContent,
		&i.ChallengeBullets,
		&i.SolutionTitle,
		&i.SolutionContent,
		&i.OutcomeTitle,
		&i.OutcomeContent,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.OgImage,
		&i.CreatedAt,
		&i.IndustryName,
		&i.IndustrySlug,
	)
	return i, err
}

const getCaseStudyBySlugIncludeDrafts = `-- name: GetCaseStudyBySlugIncludeDrafts :one
SELECT
    cs.id, cs.slug, cs.title, cs.client_name, cs.summary,
    cs.industry_id, cs.hero_image_url,
    cs.challenge_title, cs.challenge_content, cs.challenge_bullets,
    cs.solution_title, cs.solution_content,
    cs.outcome_title, cs.outcome_content,
    cs.meta_title, cs.meta_description, cs.og_image, cs.created_at,
    i.name as industry_name, i.slug as industry_slug
FROM case_studies cs
INNER JOIN industries i ON cs.industry_id = i.id
WHERE cs.slug = ?
`

type GetCaseStudyBySlugIncludeDraftsRow struct {
	ID               int64          `json:"id"`
	Slug             string         `json:"slug"`
	Title            string         `json:"title"`
	ClientName       string         `json:"client_name"`
	Summary          string         `json:"summary"`
	IndustryID       int64          `json:"industry_id"`
	HeroImageUrl     sql.NullString `json:"hero_image_url"`
	ChallengeTitle   string         `json:"challenge_title"`
	ChallengeContent string         `json:"challenge_content"`
	ChallengeBullets sql.NullString `json:"challenge_bullets"`
	SolutionTitle    string         `json:"solution_title"`
	SolutionContent  string         `json:"solution_content"`
	OutcomeTitle     string         `json:"outcome_title"`
	OutcomeContent   string         `json:"outcome_content"`
	MetaTitle        sql.NullString `json:"meta_title"`
	MetaDescription  sql.NullString `json:"meta_description"`
	OgImage          string         `json:"og_image"`
	CreatedAt        time.Time      `json:"created_at"`
	IndustryName     string         `json:"industry_name"`
	IndustrySlug     string         `json:"industry_slug"`
}

func (q *Queries) GetCaseStudyBySlugIncludeDrafts(ctx context.Context, slug string) (GetCaseStudyBySlugIncludeDraftsRow, error) {
	row := q.db.QueryRowContext(ctx, getCaseStudyBySlugIncludeDrafts, slug)
	var i GetCaseStudyBySlugIncludeDraftsRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.ClientName,
		&i.Summary,
		&i.IndustryID,
		&i.HeroImageUrl,
		&i.ChallengeTitle,
		&i.ChallengeContent,
		&i.ChallengeBullets,
		&i.SolutionTitle,
		&i.SolutionContent,
		&i.OutcomeTitle,
		&i.OutcomeContent,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.OgImage,
		&i.CreatedAt,
		&i.IndustryName,
		&i.IndustrySlug,
	)
	return i, err
}

const getCaseStudyMetrics = `-- name: GetCaseStudyMetrics :many
SELECT id, metric_value, metric_label, display_order
FROM case_study_metrics
WHERE case_study_id = ?
ORDER BY display_order ASC
`

type GetCaseStudyMetricsRow struct {
	ID           int64  `json:"id"`
	MetricValue  string `json:"metric_value"`
	MetricLabel  string `json:"metric_label"`
	DisplayOrder int64  `json:"display_order"`
}

func (q *Queries) GetCaseStudyMetrics(ctx context.Context, caseStudyID int64) ([]GetCaseStudyMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCaseStudyMetrics, caseStudyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseStudyMetricsRow{}
	for rows.Next() {
		var i GetCaseStudyMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.MetricValue,
			&i.MetricLabel,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCaseStudyProducts = `-- name: GetCaseStudyProducts :many
SELECT
    p.id, p.slug, p.name, p.tagline,
    p.primary_image, pc.name as category_name
FROM case_study_products csp
INNER JOIN products p ON csp.product_id = p.id
INNER JOIN product_categories pc ON p.category_id = pc.id
WHERE csp.case_study_id = ? AND p.status = 'published'
ORDER BY csp.display_order ASC
`

type GetCaseStudyProductsRow struct {
	ID           int64          `json:"id"`
	Slug         string         `json:"slug"`
	Name         string         `json:"name"`
	Tagline      sql.NullString `json:"tagline"`
	PrimaryImage sql.NullString `json:"primary_image"`
	CategoryName string         `json:"category_name"`
}

func (q *Queries) GetCaseStudyProducts(ctx context.Context, caseStudyID int64) ([]GetCaseStudyProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCaseStudyProducts, caseStudyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCaseStudyProductsRow{}
	for rows.Next() {
		var i GetCaseStudyProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Tagline,
			&i.PrimaryImage,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCaseStudies = `-- name: ListCaseStudies :many

SELECT
    cs.id, cs.slug, cs.title, cs.client_name, cs.summary,
    cs.hero_image_url, cs.display_order,
    i.id as industry_id, i.name as industry_name, i.slug as industry_slug
FROM case_studies cs
INNER JOIN industries i ON cs.industry_id = i.id
WHERE cs.is_published = 1
ORDER BY cs.display_order ASC, cs.created_at DESC
`

type ListCaseStudiesRow struct {
	ID           int64          `json:"id"`
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	ClientName   string         `json:"client_name"`
	Summary      string         `json:"summary"`
	HeroImageUrl sql.NullString `json:"hero_image_url"`
	DisplayOrder int64          `json:"display_order"`
	IndustryID   int64          `json:"industry_id"`
	IndustryName string         `json:"industry_name"`
	IndustrySlug string         `json:"industry_slug"`
}

// ====================================================================
// CASE STUDIES
// ====================================================================
func (q *Queries) ListCaseStudies(ctx context.Context) ([]ListCaseStudiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCaseStudies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCaseStudiesRow{}
	for rows.Next() {
		var i ListCaseStudiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.ClientName,
			&i.Summary,
			&i.HeroImageUrl,
			&i.DisplayOrder,
			&i.IndustryID,
			&i.IndustryName,
			&i.IndustrySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCaseStudiesByIndustry = `-- name: ListCaseStudiesByIndustry :many
SELECT
    cs.id, cs.slug, cs.title, cs.client_name, cs.summary,
    cs.hero_image_url, cs.display_order,
    i.id as industry_id, i.name as industry_name, i.slug as industry_slug
FROM case_studies cs
INNER JOIN industries i ON cs.industry_id = i.id
WHERE cs.is_published = 1 AND cs.industry_id = ?
ORDER BY cs.display_order ASC, cs.created_at DESC
`

type ListCaseStudiesByIndustryRow struct {
	ID           int64          `json:"id"`
	Slug         string         `json:"slug"`
	Title        string         `json:"title"`
	ClientName   string         `json:"client_name"`
	Summary      string         `json:"summary"`
	HeroImageUrl sql.NullString `json:"hero_image_url"`
	DisplayOrder int64          `json:"display_order"`
	IndustryID   int64          `json:"industry_id"`
	IndustryName string         `json:"industry_name"`
	IndustrySlug string         `json:"industry_slug"`
}

func (q *Queries) ListCaseStudiesByIndustry(ctx context.Context, industryID int64) ([]ListCaseStudiesByIndustryRow, error) {
	rows, err := q.db.QueryContext(ctx, listCaseStudiesByIndustry, industryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCaseStudiesByIndustryRow{}
	for rows.Next() {
		var i ListCaseStudiesByIndustryRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.ClientName,
			&i.Summary,
			&i.HeroImageUrl,
			&i.DisplayOrder,
			&i.IndustryID,
			&i.IndustryName,
			&i.IndustrySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
