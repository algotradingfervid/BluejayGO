// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: blog_posts.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const addProductToPost = `-- name: AddProductToPost :exec
INSERT INTO blog_post_products (blog_post_id, product_id, display_order)
VALUES (?, ?, ?)
ON CONFLICT DO NOTHING
`

type AddProductToPostParams struct {
	BlogPostID   int64         `json:"blog_post_id"`
	ProductID    int64         `json:"product_id"`
	DisplayOrder sql.NullInt64 `json:"display_order"`
}

func (q *Queries) AddProductToPost(ctx context.Context, arg AddProductToPostParams) error {
	_, err := q.db.ExecContext(ctx, addProductToPost, arg.BlogPostID, arg.ProductID, arg.DisplayOrder)
	return err
}

const addTagToPost = `-- name: AddTagToPost :exec
INSERT INTO blog_post_tags (blog_post_id, blog_tag_id)
VALUES (?, ?)
ON CONFLICT DO NOTHING
`

type AddTagToPostParams struct {
	BlogPostID int64 `json:"blog_post_id"`
	BlogTagID  int64 `json:"blog_tag_id"`
}

func (q *Queries) AddTagToPost(ctx context.Context, arg AddTagToPostParams) error {
	_, err := q.db.ExecContext(ctx, addTagToPost, arg.BlogPostID, arg.BlogTagID)
	return err
}

const clearPostProducts = `-- name: ClearPostProducts :exec
DELETE FROM blog_post_products WHERE blog_post_id = ?
`

func (q *Queries) ClearPostProducts(ctx context.Context, blogPostID int64) error {
	_, err := q.db.ExecContext(ctx, clearPostProducts, blogPostID)
	return err
}

const clearPostTags = `-- name: ClearPostTags :exec
DELETE FROM blog_post_tags WHERE blog_post_id = ?
`

func (q *Queries) ClearPostTags(ctx context.Context, blogPostID int64) error {
	_, err := q.db.ExecContext(ctx, clearPostTags, blogPostID)
	return err
}

const countBlogPostsAdminFiltered = `-- name: CountBlogPostsAdminFiltered :one
SELECT COUNT(*) FROM blog_posts bp
WHERE
    (CASE WHEN ?1 = '' THEN 1 ELSE bp.status = ?1 END)
    AND (CASE WHEN ?2 = 0 THEN 1 ELSE bp.category_id = ?2 END)
    AND (CASE WHEN ?3 = 0 THEN 1 ELSE bp.author_id = ?3 END)
    AND (CASE WHEN ?4 = '' THEN 1 ELSE (bp.title LIKE '%' || ?4 || '%' OR bp.slug LIKE '%' || ?4 || '%') END)
`

type CountBlogPostsAdminFilteredParams struct {
	FilterStatus   interface{} `json:"filter_status"`
	FilterCategory interface{} `json:"filter_category"`
	FilterAuthor   interface{} `json:"filter_author"`
	FilterSearch   interface{} `json:"filter_search"`
}

func (q *Queries) CountBlogPostsAdminFiltered(ctx context.Context, arg CountBlogPostsAdminFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBlogPostsAdminFiltered,
		arg.FilterStatus,
		arg.FilterCategory,
		arg.FilterAuthor,
		arg.FilterSearch,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPosts = `-- name: CountPublishedPosts :one
SELECT COUNT(*) FROM blog_posts
WHERE status = 'published' AND published_at IS NOT NULL
`

func (q *Queries) CountPublishedPosts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPosts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPostsByCategory = `-- name: CountPublishedPostsByCategory :one
SELECT COUNT(*) FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
WHERE bp.status = 'published'
    AND bp.published_at IS NOT NULL
    AND bc.slug = ?
`

func (q *Queries) CountPublishedPostsByCategory(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPostsByCategory, slug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBlogPost = `-- name: CreateBlogPost :one
INSERT INTO blog_posts (
    title, slug, excerpt, body, featured_image_url, featured_image_alt,
    category_id, author_id, meta_description, reading_time_minutes,
    status, published_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id, title, slug, excerpt, body, featured_image_url, featured_image_alt, category_id, author_id, meta_description, reading_time_minutes, status, published_at, created_at, updated_at, meta_title, og_image
`

type CreateBlogPostParams struct {
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	Body               string         `json:"body"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	AuthorID           int64          `json:"author_id"`
	MetaDescription    sql.NullString `json:"meta_description"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	Status             string         `json:"status"`
	PublishedAt        sql.NullTime   `json:"published_at"`
}

func (q *Queries) CreateBlogPost(ctx context.Context, arg CreateBlogPostParams) (BlogPost, error) {
	row := q.db.QueryRowContext(ctx, createBlogPost,
		arg.Title,
		arg.Slug,
		arg.Excerpt,
		arg.Body,
		arg.FeaturedImageUrl,
		arg.FeaturedImageAlt,
		arg.CategoryID,
		arg.AuthorID,
		arg.MetaDescription,
		arg.ReadingTimeMinutes,
		arg.Status,
		arg.PublishedAt,
	)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Excerpt,
		&i.Body,
		&i.FeaturedImageUrl,
		&i.FeaturedImageAlt,
		&i.CategoryID,
		&i.AuthorID,
		&i.MetaDescription,
		&i.ReadingTimeMinutes,
		&i.Status,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MetaTitle,
		&i.OgImage,
	)
	return i, err
}

const deleteBlogPost = `-- name: DeleteBlogPost :exec
DELETE FROM blog_posts WHERE id = ?
`

func (q *Queries) DeleteBlogPost(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBlogPost, id)
	return err
}

const getBlogPost = `-- name: GetBlogPost :one
SELECT id, title, slug, excerpt, body, featured_image_url, featured_image_alt, category_id, author_id, meta_description, reading_time_minutes, status, published_at, created_at, updated_at, meta_title, og_image FROM blog_posts WHERE id = ?
`

func (q *Queries) GetBlogPost(ctx context.Context, id int64) (BlogPost, error) {
	row := q.db.QueryRowContext(ctx, getBlogPost, id)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Excerpt,
		&i.Body,
		&i.FeaturedImageUrl,
		&i.FeaturedImageAlt,
		&i.CategoryID,
		&i.AuthorID,
		&i.MetaDescription,
		&i.ReadingTimeMinutes,
		&i.Status,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MetaTitle,
		&i.OgImage,
	)
	return i, err
}

const getFeaturedPost = `-- name: GetFeaturedPost :one
SELECT
    bp.id, bp.title, bp.slug, bp.excerpt, bp.featured_image_url, bp.featured_image_alt,
    bp.category_id, bc.name AS category_name, bc.slug AS category_slug, bc.color_hex AS category_color,
    bp.author_id, ba.name AS author_name, ba.avatar_url AS author_avatar,
    bp.reading_time_minutes, bp.published_at
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
WHERE bp.status = 'published' AND bp.published_at IS NOT NULL
ORDER BY bp.published_at DESC
LIMIT 1
`

type GetFeaturedPostRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	CategoryName       string         `json:"category_name"`
	CategorySlug       string         `json:"category_slug"`
	CategoryColor      string         `json:"category_color"`
	AuthorID           int64          `json:"author_id"`
	AuthorName         string         `json:"author_name"`
	AuthorAvatar       sql.NullString `json:"author_avatar"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
}

func (q *Queries) GetFeaturedPost(ctx context.Context) (GetFeaturedPostRow, error) {
	row := q.db.QueryRowContext(ctx, getFeaturedPost)
	var i GetFeaturedPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Excerpt,
		&i.FeaturedImageUrl,
		&i.FeaturedImageAlt,
		&i.CategoryID,
		&i.CategoryName,
		&i.CategorySlug,
		&i.CategoryColor,
		&i.AuthorID,
		&i.AuthorName,
		&i.AuthorAvatar,
		&i.ReadingTimeMinutes,
		&i.PublishedAt,
	)
	return i, err
}

const getPostBySlugIncludeDrafts = `-- name: GetPostBySlugIncludeDrafts :one
SELECT
    bp.id, bp.title, bp.slug, bp.excerpt, bp.body,
    bp.featured_image_url, bp.featured_image_alt,
    bp.category_id, bc.name AS category_name, bc.slug AS category_slug, bc.color_hex AS category_color,
    bp.author_id, ba.name AS author_name, ba.bio AS author_bio,
    ba.avatar_url AS author_avatar, ba.linkedin_url AS author_linkedin,
    bp.reading_time_minutes, bp.published_at, bp.meta_description,
    bp.meta_title, bp.og_image
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
WHERE bp.slug = ?
`

type GetPostBySlugIncludeDraftsRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	Body               string         `json:"body"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	CategoryName       string         `json:"category_name"`
	CategorySlug       string         `json:"category_slug"`
	CategoryColor      string         `json:"category_color"`
	AuthorID           int64          `json:"author_id"`
	AuthorName         string         `json:"author_name"`
	AuthorBio          sql.NullString `json:"author_bio"`
	AuthorAvatar       sql.NullString `json:"author_avatar"`
	AuthorLinkedin     sql.NullString `json:"author_linkedin"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	MetaDescription    sql.NullString `json:"meta_description"`
	MetaTitle          string         `json:"meta_title"`
	OgImage            string         `json:"og_image"`
}

func (q *Queries) GetPostBySlugIncludeDrafts(ctx context.Context, slug string) (GetPostBySlugIncludeDraftsRow, error) {
	row := q.db.QueryRowContext(ctx, getPostBySlugIncludeDrafts, slug)
	var i GetPostBySlugIncludeDraftsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Excerpt,
		&i.Body,
		&i.FeaturedImageUrl,
		&i.FeaturedImageAlt,
		&i.CategoryID,
		&i.CategoryName,
		&i.CategorySlug,
		&i.CategoryColor,
		&i.AuthorID,
		&i.AuthorName,
		&i.AuthorBio,
		&i.AuthorAvatar,
		&i.AuthorLinkedin,
		&i.ReadingTimeMinutes,
		&i.PublishedAt,
		&i.MetaDescription,
		&i.MetaTitle,
		&i.OgImage,
	)
	return i, err
}

const getPostProductsByPostID = `-- name: GetPostProductsByPostID :many
SELECT p.id, p.name, p.slug, p.primary_image, p.tagline, pc.slug AS category_slug, pc.name AS category_name
FROM products p
INNER JOIN blog_post_products bpp ON p.id = bpp.product_id
INNER JOIN product_categories pc ON p.category_id = pc.id
WHERE bpp.blog_post_id = ?
ORDER BY bpp.display_order, p.name
`

type GetPostProductsByPostIDRow struct {
	ID           int64          `json:"id"`
	Name         string         `json:"name"`
	Slug         string         `json:"slug"`
	PrimaryImage sql.NullString `json:"primary_image"`
	Tagline      sql.NullString `json:"tagline"`
	CategorySlug string         `json:"category_slug"`
	CategoryName string         `json:"category_name"`
}

func (q *Queries) GetPostProductsByPostID(ctx context.Context, blogPostID int64) ([]GetPostProductsByPostIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostProductsByPostID, blogPostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostProductsByPostIDRow{}
	for rows.Next() {
		var i GetPostProductsByPostIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.PrimaryImage,
			&i.Tagline,
			&i.CategorySlug,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostTagsByPostID = `-- name: GetPostTagsByPostID :many
SELECT bt.id, bt.name, bt.slug
FROM blog_tags bt
INNER JOIN blog_post_tags bpt ON bt.id = bpt.blog_tag_id
WHERE bpt.blog_post_id = ?
ORDER BY bt.name
`

type GetPostTagsByPostIDRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

func (q *Queries) GetPostTagsByPostID(ctx context.Context, blogPostID int64) ([]GetPostTagsByPostIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostTagsByPostID, blogPostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostTagsByPostIDRow{}
	for rows.Next() {
		var i GetPostTagsByPostIDRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishedPostBySlug = `-- name: GetPublishedPostBySlug :one
SELECT
    bp.id, bp.title, bp.slug, bp.excerpt, bp.body,
    bp.featured_image_url, bp.featured_image_alt,
    bp.category_id, bc.name AS category_name, bc.slug AS category_slug, bc.color_hex AS category_color,
    bp.author_id, ba.name AS author_name, ba.bio AS author_bio,
    ba.avatar_url AS author_avatar, ba.linkedin_url AS author_linkedin,
    bp.reading_time_minutes, bp.published_at, bp.meta_description,
    bp.meta_title, bp.og_image
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
WHERE bp.slug = ? AND bp.status = 'published' AND bp.published_at IS NOT NULL
`

type GetPublishedPostBySlugRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	Body               string         `json:"body"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	CategoryName       string         `json:"category_name"`
	CategorySlug       string         `json:"category_slug"`
	CategoryColor      string         `json:"category_color"`
	AuthorID           int64          `json:"author_id"`
	AuthorName         string         `json:"author_name"`
	AuthorBio          sql.NullString `json:"author_bio"`
	AuthorAvatar       sql.NullString `json:"author_avatar"`
	AuthorLinkedin     sql.NullString `json:"author_linkedin"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	MetaDescription    sql.NullString `json:"meta_description"`
	MetaTitle          string         `json:"meta_title"`
	OgImage            string         `json:"og_image"`
}

func (q *Queries) GetPublishedPostBySlug(ctx context.Context, slug string) (GetPublishedPostBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getPublishedPostBySlug, slug)
	var i GetPublishedPostBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Excerpt,
		&i.Body,
		&i.FeaturedImageUrl,
		&i.FeaturedImageAlt,
		&i.CategoryID,
		&i.CategoryName,
		&i.CategorySlug,
		&i.CategoryColor,
		&i.AuthorID,
		&i.AuthorName,
		&i.AuthorBio,
		&i.AuthorAvatar,
		&i.AuthorLinkedin,
		&i.ReadingTimeMinutes,
		&i.PublishedAt,
		&i.MetaDescription,
		&i.MetaTitle,
		&i.OgImage,
	)
	return i, err
}

const getRelatedPosts = `-- name: GetRelatedPosts :many
SELECT
    bp.id, bp.title, bp.slug, bp.featured_image_url, bp.featured_image_alt,
    bc.name AS category_name, bc.slug AS category_slug, bc.color_hex AS category_color,
    bp.reading_time_minutes, bp.published_at
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
WHERE bp.status = 'published'
    AND bp.published_at IS NOT NULL
    AND bp.category_id = ?
    AND bp.id != ?
ORDER BY bp.published_at DESC
LIMIT ?
`

type GetRelatedPostsParams struct {
	CategoryID int64 `json:"category_id"`
	ID         int64 `json:"id"`
	Limit      int64 `json:"limit"`
}

type GetRelatedPostsRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryName       string         `json:"category_name"`
	CategorySlug       string         `json:"category_slug"`
	CategoryColor      string         `json:"category_color"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
}

func (q *Queries) GetRelatedPosts(ctx context.Context, arg GetRelatedPostsParams) ([]GetRelatedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedPosts, arg.CategoryID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelatedPostsRow{}
	for rows.Next() {
		var i GetRelatedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.FeaturedImageUrl,
			&i.FeaturedImageAlt,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryColor,
			&i.ReadingTimeMinutes,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllBlogPosts = `-- name: ListAllBlogPosts :many
SELECT
    bp.id, bp.title, bp.slug, bp.status, bp.category_id, bc.name AS category_name,
    bp.author_id, ba.name AS author_name, bp.published_at, bp.created_at, bp.updated_at
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
ORDER BY bp.created_at DESC
`

type ListAllBlogPostsRow struct {
	ID           int64        `json:"id"`
	Title        string       `json:"title"`
	Slug         string       `json:"slug"`
	Status       string       `json:"status"`
	CategoryID   int64        `json:"category_id"`
	CategoryName string       `json:"category_name"`
	AuthorID     int64        `json:"author_id"`
	AuthorName   string       `json:"author_name"`
	PublishedAt  sql.NullTime `json:"published_at"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
}

func (q *Queries) ListAllBlogPosts(ctx context.Context) ([]ListAllBlogPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllBlogPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllBlogPostsRow{}
	for rows.Next() {
		var i ListAllBlogPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Status,
			&i.CategoryID,
			&i.CategoryName,
			&i.AuthorID,
			&i.AuthorName,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBlogPostsAdminFiltered = `-- name: ListBlogPostsAdminFiltered :many
SELECT
    bp.id, bp.title, bp.slug, bp.excerpt, bp.featured_image_url, bp.featured_image_alt,
    bp.status, bp.category_id, bc.name AS category_name,
    bp.author_id, ba.name AS author_name, ba.avatar_url AS author_avatar,
    bp.reading_time_minutes, bp.published_at, bp.created_at, bp.updated_at
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
WHERE
    (CASE WHEN ?1 = '' THEN 1 ELSE bp.status = ?1 END)
    AND (CASE WHEN ?2 = 0 THEN 1 ELSE bp.category_id = ?2 END)
    AND (CASE WHEN ?3 = 0 THEN 1 ELSE bp.author_id = ?3 END)
    AND (CASE WHEN ?4 = '' THEN 1 ELSE (bp.title LIKE '%' || ?4 || '%' OR bp.slug LIKE '%' || ?4 || '%') END)
ORDER BY bp.created_at DESC
LIMIT ?6 OFFSET ?5
`

type ListBlogPostsAdminFilteredParams struct {
	FilterStatus   interface{} `json:"filter_status"`
	FilterCategory interface{} `json:"filter_category"`
	FilterAuthor   interface{} `json:"filter_author"`
	FilterSearch   interface{} `json:"filter_search"`
	PageOffset     int64       `json:"page_offset"`
	PageLimit      int64       `json:"page_limit"`
}

type ListBlogPostsAdminFilteredRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	Status             string         `json:"status"`
	CategoryID         int64          `json:"category_id"`
	CategoryName       string         `json:"category_name"`
	AuthorID           int64          `json:"author_id"`
	AuthorName         string         `json:"author_name"`
	AuthorAvatar       sql.NullString `json:"author_avatar"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
}

func (q *Queries) ListBlogPostsAdminFiltered(ctx context.Context, arg ListBlogPostsAdminFilteredParams) ([]ListBlogPostsAdminFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, listBlogPostsAdminFiltered,
		arg.FilterStatus,
		arg.FilterCategory,
		arg.FilterAuthor,
		arg.FilterSearch,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBlogPostsAdminFilteredRow{}
	for rows.Next() {
		var i ListBlogPostsAdminFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Excerpt,
			&i.FeaturedImageUrl,
			&i.FeaturedImageAlt,
			&i.Status,
			&i.CategoryID,
			&i.CategoryName,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorAvatar,
			&i.ReadingTimeMinutes,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLatestPublishedPosts = `-- name: ListLatestPublishedPosts :many
SELECT
    bp.id, bp.title, bp.slug, bp.excerpt, bp.featured_image_url, bp.featured_image_alt,
    bp.category_id, bc.name AS category_name, bc.slug AS category_slug, bc.color_hex AS category_color,
    bp.author_id, ba.name AS author_name, ba.avatar_url AS author_avatar,
    bp.reading_time_minutes, bp.published_at, bp.created_at
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
WHERE bp.status = 'published' AND bp.published_at IS NOT NULL
ORDER BY bp.published_at DESC
LIMIT ?
`

type ListLatestPublishedPostsRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	CategoryName       string         `json:"category_name"`
	CategorySlug       string         `json:"category_slug"`
	CategoryColor      string         `json:"category_color"`
	AuthorID           int64          `json:"author_id"`
	AuthorName         string         `json:"author_name"`
	AuthorAvatar       sql.NullString `json:"author_avatar"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	CreatedAt          time.Time      `json:"created_at"`
}

func (q *Queries) ListLatestPublishedPosts(ctx context.Context, limit int64) ([]ListLatestPublishedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listLatestPublishedPosts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLatestPublishedPostsRow{}
	for rows.Next() {
		var i ListLatestPublishedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Excerpt,
			&i.FeaturedImageUrl,
			&i.FeaturedImageAlt,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryColor,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorAvatar,
			&i.ReadingTimeMinutes,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPosts = `-- name: ListPublishedPosts :many
SELECT
    bp.id, bp.title, bp.slug, bp.excerpt, bp.featured_image_url, bp.featured_image_alt,
    bp.category_id, bc.name AS category_name, bc.slug AS category_slug, bc.color_hex AS category_color,
    bp.author_id, ba.name AS author_name, ba.avatar_url AS author_avatar,
    bp.reading_time_minutes, bp.published_at, bp.created_at
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
WHERE bp.status = 'published' AND bp.published_at IS NOT NULL
ORDER BY bp.published_at DESC
LIMIT ? OFFSET ?
`

type ListPublishedPostsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListPublishedPostsRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	CategoryName       string         `json:"category_name"`
	CategorySlug       string         `json:"category_slug"`
	CategoryColor      string         `json:"category_color"`
	AuthorID           int64          `json:"author_id"`
	AuthorName         string         `json:"author_name"`
	AuthorAvatar       sql.NullString `json:"author_avatar"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	CreatedAt          time.Time      `json:"created_at"`
}

func (q *Queries) ListPublishedPosts(ctx context.Context, arg ListPublishedPostsParams) ([]ListPublishedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedPostsRow{}
	for rows.Next() {
		var i ListPublishedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Excerpt,
			&i.FeaturedImageUrl,
			&i.FeaturedImageAlt,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryColor,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorAvatar,
			&i.ReadingTimeMinutes,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPostsByCategory = `-- name: ListPublishedPostsByCategory :many
SELECT
    bp.id, bp.title, bp.slug, bp.excerpt, bp.featured_image_url, bp.featured_image_alt,
    bp.category_id, bc.name AS category_name, bc.slug AS category_slug, bc.color_hex AS category_color,
    bp.author_id, ba.name AS author_name, ba.avatar_url AS author_avatar,
    bp.reading_time_minutes, bp.published_at, bp.created_at
FROM blog_posts bp
INNER JOIN blog_categories bc ON bp.category_id = bc.id
INNER JOIN blog_authors ba ON bp.author_id = ba.id
WHERE bp.status = 'published'
    AND bp.published_at IS NOT NULL
    AND bc.slug = ?
ORDER BY bp.published_at DESC
LIMIT ? OFFSET ?
`

type ListPublishedPostsByCategoryParams struct {
	Slug   string `json:"slug"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

type ListPublishedPostsByCategoryRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	CategoryName       string         `json:"category_name"`
	CategorySlug       string         `json:"category_slug"`
	CategoryColor      string         `json:"category_color"`
	AuthorID           int64          `json:"author_id"`
	AuthorName         string         `json:"author_name"`
	AuthorAvatar       sql.NullString `json:"author_avatar"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	CreatedAt          time.Time      `json:"created_at"`
}

func (q *Queries) ListPublishedPostsByCategory(ctx context.Context, arg ListPublishedPostsByCategoryParams) ([]ListPublishedPostsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPostsByCategory, arg.Slug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedPostsByCategoryRow{}
	for rows.Next() {
		var i ListPublishedPostsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Excerpt,
			&i.FeaturedImageUrl,
			&i.FeaturedImageAlt,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategorySlug,
			&i.CategoryColor,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorAvatar,
			&i.ReadingTimeMinutes,
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromPost = `-- name: RemoveTagFromPost :exec
DELETE FROM blog_post_tags
WHERE blog_post_id = ? AND blog_tag_id = ?
`

type RemoveTagFromPostParams struct {
	BlogPostID int64 `json:"blog_post_id"`
	BlogTagID  int64 `json:"blog_tag_id"`
}

func (q *Queries) RemoveTagFromPost(ctx context.Context, arg RemoveTagFromPostParams) error {
	_, err := q.db.ExecContext(ctx, removeTagFromPost, arg.BlogPostID, arg.BlogTagID)
	return err
}

const searchPublishedProducts = `-- name: SearchPublishedProducts :many
SELECT id, name, slug, primary_image FROM products
WHERE status = 'published' AND name LIKE ?
ORDER BY name LIMIT 10
`

type SearchPublishedProductsRow struct {
	ID           int64          `json:"id"`
	Name         string         `json:"name"`
	Slug         string         `json:"slug"`
	PrimaryImage sql.NullString `json:"primary_image"`
}

func (q *Queries) SearchPublishedProducts(ctx context.Context, name string) ([]SearchPublishedProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchPublishedProducts, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPublishedProductsRow{}
	for rows.Next() {
		var i SearchPublishedProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.PrimaryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlogPost = `-- name: UpdateBlogPost :one
UPDATE blog_posts SET
    title = ?,
    slug = ?,
    excerpt = ?,
    body = ?,
    featured_image_url = ?,
    featured_image_alt = ?,
    category_id = ?,
    author_id = ?,
    meta_description = ?,
    reading_time_minutes = ?,
    status = ?,
    published_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, slug, excerpt, body, featured_image_url, featured_image_alt, category_id, author_id, meta_description, reading_time_minutes, status, published_at, created_at, updated_at, meta_title, og_image
`

type UpdateBlogPostParams struct {
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Excerpt            string         `json:"excerpt"`
	Body               string         `json:"body"`
	FeaturedImageUrl   sql.NullString `json:"featured_image_url"`
	FeaturedImageAlt   sql.NullString `json:"featured_image_alt"`
	CategoryID         int64          `json:"category_id"`
	AuthorID           int64          `json:"author_id"`
	MetaDescription    sql.NullString `json:"meta_description"`
	ReadingTimeMinutes sql.NullInt64  `json:"reading_time_minutes"`
	Status             string         `json:"status"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	ID                 int64          `json:"id"`
}

func (q *Queries) UpdateBlogPost(ctx context.Context, arg UpdateBlogPostParams) (BlogPost, error) {
	row := q.db.QueryRowContext(ctx, updateBlogPost,
		arg.Title,
		arg.Slug,
		arg.Excerpt,
		arg.Body,
		arg.FeaturedImageUrl,
		arg.FeaturedImageAlt,
		arg.CategoryID,
		arg.AuthorID,
		arg.MetaDescription,
		arg.ReadingTimeMinutes,
		arg.Status,
		arg.PublishedAt,
		arg.ID,
	)
	var i BlogPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Excerpt,
		&i.Body,
		&i.FeaturedImageUrl,
		&i.FeaturedImageAlt,
		&i.CategoryID,
		&i.AuthorID,
		&i.MetaDescription,
		&i.ReadingTimeMinutes,
		&i.Status,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MetaTitle,
		&i.OgImage,
	)
	return i, err
}
